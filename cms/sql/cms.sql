/*
 Navicat Premium Data Transfer

 Source Server         : guoshun
 Source Server Type    : MySQL
 Source Server Version : 80017
 Source Host           : localhost:3306
 Source Schema         : cms

 Target Server Type    : MySQL
 Target Server Version : 80017
 File Encoding         : 65001

 Date: 03/01/2021 21:36:17
*/

SET NAMES utf8mb4;
SET FOREIGN_KEY_CHECKS = 0;

-- ----------------------------
-- Table structure for tb_article
-- ----------------------------
DROP TABLE IF EXISTS `tb_article`;
CREATE TABLE `tb_article`  (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `channel_id` int(11) NOT NULL COMMENT '栏目id',
  `title` varchar(100) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NULL DEFAULT NULL COMMENT '标题',
  `title_img` varchar(100) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NULL DEFAULT NULL COMMENT '标题图',
  `summary` text CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NULL COMMENT '摘要',
  `url` varchar(100) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NULL DEFAULT NULL COMMENT '外链URL',
  `content` mediumtext CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NULL COMMENT '正文',
  `status` int(1) NULL DEFAULT NULL COMMENT '0待发布1发布',
  `comment_status` int(1) NULL DEFAULT NULL COMMENT '0/Null允许评论，不允许评论',
  `rotation` int(1) NULL DEFAULT NULL COMMENT '0/NULL非轮播 1 轮播',
  `top` int(1) NULL DEFAULT NULL COMMENT '0/null不置顶，1置顶',
  `orderby` int(11) NULL DEFAULT NULL COMMENT '排序',
  `create_date` date NULL DEFAULT NULL COMMENT '创建时间',
  `create_user` int(11) NULL DEFAULT NULL COMMENT '创建人',
  `update_date` date NULL DEFAULT NULL,
  `article_view` int(11) NULL DEFAULT 0,
  PRIMARY KEY (`id`) USING BTREE
) ENGINE = InnoDB AUTO_INCREMENT = 56 CHARACTER SET = utf8mb4 COLLATE = utf8mb4_0900_ai_ci COMMENT = '文章' ROW_FORMAT = Dynamic;

-- ----------------------------
-- Records of tb_article
-- ----------------------------
INSERT INTO `tb_article` VALUES (22, 20, 'spring', '', '1 Spring     1 1简介  - Spring 春天---------- 给原件行业带来春天 - 2002 首次推出了Spring框架雏形 interface21框架 - 2004年3月24号Spring发布了1 0正式版 - Rod Johnson   Spring Framework创始人  著名作者  很难想象Rod Johnson的学历 真的让好多人大吃一惊 他是 悉尼大学  https   baike baidu com item 悉尼大学 的博士 然而他的专业不是计算机 而是音乐学   - Spring理念 使现有的技术更加容易使用 本身是一个大杂烩 整合了现有的技术框架', '', '\n\n\n\n# 1、Spring\n\n## 1.1简介\n\n- Spring：春天---------->给原件行业带来春天\n- 2002,首次推出了Spring框架雏形:interface21框架\n- 2004年3月24号Spring发布了1.0正式版\n- Rod Johnson ， Spring Framework创始人 ，著名作者。 很难想象Rod Johnson的学历，真的让好多人大吃一惊，他是[悉尼大学](https://baike.baidu.com/item/悉尼大学)的博士，然而他的专业不是计算机，而是音乐学。 \n- Spring理念：使现有的技术更加容易使用，本身是一个大杂烩，整合了现有的技术框架！\n\n\n\n- SSH :	Struct2+Spring+Hibernate!\n- SSM：  SpringMVC+Spring+Mybatis!\n\n- 官网: https://spring.io/projects/spring-framework \n- 官方下载地址: [http://repo.spring.io/release/org/springframework/spring](https://repo.spring.io/release/org/springframework/spring)  \n- GitHub: https://github.com/spring-projects/spring-framework \n\n```xml\n<!-- https://mvnrepository.com/artifact/org.springframework/spring-webmvc -->\n<dependency>\n    <groupId>org.springframework</groupId>\n    <artifactId>spring-webmvc</artifactId>\n    <version>5.2.0.RELEASE</version>\n</dependency>\n<!-- https://mvnrepository.com/artifact/org.springframework/spring-webmvc -->\n<dependency>\n    <groupId>org.springframework</groupId>\n    <artifactId>spring-jdbc</artifactId>\n    <version>5.2.0.RELEASE</version>\n</dependency>\n```\n\n\n\n## 1.2、优点\n\n- Spring是一个开源的免费的框架(容器)！\n- Spring是一个轻量级的、非入侵 式的框架！\n- 控制反转(IOC)，面向切面编程(AOP)！\n- 支持事务的处理，对框架整合的支持！\n\n==总结一句话:Spring就是一个轻量级的控制反转(IOC)和面向切面编程（AOP）的框架！==\n\n\n\n## 1.3组成\n\n![1576133682226](C:\\Users\\guosz\\AppData\\Roaming\\Typora\\typora-user-images\\1576133682226.png)\n\n\n\n## 1.4拓展\n\n在Spring的官网有这个介绍:现代化的java开发!说白就是基于Spring的开发\n\n![1576133880492](C:\\Users\\guosz\\AppData\\Roaming\\Typora\\typora-user-images\\1576133880492.png)\n\n\n\n- Spring Boot\n  - 快速开发的脚手架。\n  - 基于Spring Boot可以快速的开发单个微服务。\n  - 约定大于配置！\n- Spring Cloud\n  - Spring Cloud是基于Spring Boot实现的\n\n因为现在大多数公司都在使用Spring Boot进行快速开发，学习Spring Boot的前提，需要完全掌握Spring及Spring MVC!承上启下的作用!\n\n\n\n**弊端:发展了太久之后,违背了原来的理念!配置十分繁琐，人称配置地狱**\n\n\n\n# 2、IOC理论推导\n\n1.UserDao接口\n\n2.UserDaoImpl实现类\n\n3.UserService业务接口\n\n4.UserServiceImpl 业务实现类\n\n\n\n在我们之前的业务中，用户的需求可能会影响我们原来的代码，我们需要根据用户的需求去修改原代码！如果程序代码量十分大，修改一次的成本代价十分昂贵！\n\n![1576217867883](C:\\Users\\guosz\\AppData\\Roaming\\Typora\\typora-user-images\\1576217867883.png)\n\n我们使用一个Set接口实现. 已经发生了革命性的变化\n\n```java\n private UserDao userDao;\n    //利用set进行动态实现值的注入\n    public  void setUserDao(UserDao userDao) {\n        this.userDao = userDao;\n    }\n```\n\n- 之前，程序是主动创建对象！控制权在程序员手上！\n- 使用set注入后，程序不在具有主动性，而是变成了被动的接受对象!\n\n这种思想，从本质上解决了问题，我们程序员不用再去管理对象的创建了。系统的耦合性大大将达~，可以更加专注的在业务的实现！这是IOC的原型\n\n\n\n![1576217839709](C:\\Users\\guosz\\AppData\\Roaming\\Typora\\typora-user-images\\1576217839709.png)\n\n\n\n\n\n##  IOC本质\n\n控制反转IoC(Inversion of Control)，是一种设计思想，DI(依赖注入)是实现IoC的一种方法**，也有人认为DI只是IoC的另一种说法。没有IoC的程序中 , 我们使用面向对象编程 , 对象的创建与对象间的依赖关系完全硬编码在程序中，对象的创建由程序自己控制，控制反转后将对象的创建转移给第三方，个人认为所谓控制反转就是：获得依赖对象的方式反转了。 \n\n\n\n 采用XML方式配置Bean的时候，Bean的定义信息是和实现分离的，而采用注解的方式可以把两者合为一体，Bean的定义信息直接以注解的形式定义在实现类中，从而达到了零配置的目的。 \n\n **控制反转是一种通过描述（XML或注解）并通过第三方去生产或获取特定对象的方式。在Spring中实现控制反转的是IoC容器，其实现方法是依赖注入（Dependency Injection,DI）。** \n\n\n\n# 3、HelloSpring\n\n## 1.导入Spring相关的jar包\n\n注 : spring 需要导入commons-logging进行日志记录 . 我们利用maven , 他会自动下载对应的依赖项 .\n\n```xml\n<dependency>\n    <groupId>org.springframework</groupId>\n    <artifactId>spring-webmvc</artifactId>\n    <version>5.1.10.RELEASE</version>\n</dependency>\n```\n\n \n\n## 2.编写相关代码\n\n```java\n public class Hello {\n     private String name;\n \n     public String getName() {\n         return name;\n     }\n     public void setName(String name) {\n         this.name = name;\n     }\n \n     public void show(){\n         System.out.println(\"Hello\"+ name );\n     }\n }\n```\n\n \n\n2.2 写编写我们的spring文件 , 这里我们命名为beans.xml\n\n```xml\n   <?xml version=\"1.0\" encoding=\"UTF-8\"?>\n   <beans xmlns=\"http://www.springframework.org/schema/beans\"\n          xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n          xsi:schemaLocation=\"http://www.springframework.org/schema/beans\n           http://www.springframework.org/schema/beans/spring-beans.xsd\">\n   \n       <!--bean就是java对象 , 由Spring创建和管理-->\n       <bean id=\"hello\" class=\"com.kuang.pojo.Hello\">\n          <property name=\"name\" value=\"Spring\"/>\n      </bean>\n  \n  </beans>\n```\n\n \n\n2.3 我们可以去进行测试了 \n\n```java\n @Test\n public void test(){\n     //解析beans.xml文件 , 生成管理相应的Bean对象\n     ApplicationContext context = newClassPathXmlApplicationContext(\"beans.xml\");\n     //getBean : 参数即为spring配置文件中bean的id .\n     Hello hello = (Hello) context.getBean(\"hello\");\n     hello.show();\n }\n```\n\n \n\n### 思考问题 ?\n\n- Hello 对象是谁创建的 ?\n\n  hello 对象是由Spring创建的\n\n- Hello 对象的属性是怎么设置的 ?\n\n  hello 对象的属性是由Spring容器设置的 ,\n\n这个过程就叫控制反转 :\n\n控制 : 谁来控制对象的创建 , 传统应用程序的对象是由程序本身控制创建的 , 使用Spring后 , 对象是由Spring来创建的 .\n\n反转 : 程序本身不创建对象 , 而变成被动的接收对象 .\n\n依赖注入 : 就是利用set方法来进行注入的.\n\nIOC是一种编程思想 , 由主动的编程变成被动的接收 .\n\n可以通过newClassPathXmlApplicationContext去浏览一下底层源码 .\n\n**OK , 到了现在 , 我们彻底不用再程序中去改动了 , 要实现不同的操作 , 只需要在xml配置文件中进行修改 , 所谓的IoC,一句话搞定 : 对象由Spring 来创建 , 管理 , 装配 !**\n\n\n\n# 4.IOC创建对象的方式\n\n1.使用无惨构造创建对象，默认！\n\n2.假设我了吧要使用有参构造创建对象\n\n## 	1.下标赋值\n\n```xml\n<!--第一种下标赋值-->\n<bean id=\"user\" class=\"com.Gosion.pojo.User\">    \n    <constructor-arg index=\"0\" value=\"Gosion学java\"/>\n</bean>\n```\n\n## 	2.类型\n\n```xml\n<!--第二种方式:通过类型创建,不建议使用-->\n    <bean id=\"user\" class=\"com.Gosion.pojo.User\">\n        <constructor-arg type=\"java.lang.String\" value=\"国顺\"/>\n    </bean>\n```\n\n## 	3.通过参数名赋值\n\n```xml\n  <!--第三种 : 直接通过参数名来设置-->\n    <bean id=\"user\" class=\"com.Gosion.pojo.User\">\n        <constructor-arg name=\"name\" value=\"Guoshun\"/>\n    </bean>\n```\n\n\n\n总结:在配置文件中加载的时候，容器中管理的对象就已经初始化了！\n\n\n\n# 5、Spring配置\n\n## 5.1、别名\n\n```xml\n<!--别名,如果添加了别名，我们也可以使用别名来获取这个对象-->\n    <alias name=\"user\" alias=\"usernew\"/>\n```\n\n\n\n## 5.2、Bean的配置\n\n```xml\n    <!--\n    id:bean的唯一标识符，也就是相当于我们学的对象名\n    class:bean  对象所对应的全限定名:包名+类名\n    name: 也是别名,而且name可以同时取多个别名\n    -->\n    <bean id=\"userT\" class=\"com.Gosion.pojo.UserT\" name=\"userT2\">\n\n    </bean>\n```\n\n\n\n\n\n## 5.3 、import\n\n这个import，一般用于团队开发使用，他可以将多个配置文件\n\n假设，现在项目中有多个人开发，这三个人负责不同的类开发，不同的类需要注册在不同的bean中，我们可以利用import将所有人的beans.xml合并为总的！\n\n- 张三\n- 李四\n- 王五\n- applicationContext.xml\n\n```.xml\n <import resource=\"beans.xml\"/>\n    <import resource=\"beans2.xml\"/>\n```\n\n\n\n使用的时候，直接使用中的配置就可以了\n\n\n\n# 6、依赖注入\n\n\n\n## 6.1、构造器注入\n\n前面已经说过了\n\n\n\n## 6.2、Set方式注入【重点】\n\n- 依赖注入:set注入！\n  - 依赖：bean对象的创建依赖于容器\n  - 注入:   bean对象中的所有属性，由容器来注入\n\n\n\n【环境搭建】\n\n​	1.复杂类型\n\n```java\npublic class Address {\n    private String address;\n\n    public String getAddress() {\n        return address;\n    }\n\n    public void setAddress(String address) {\n        this.address = address;\n    }\n}\n```\n\n\n\n​	2.真实测试对象\n\n```java\npublic class Student {\n    private String name;\n    private Address address;\n    private String[] books;\n    private List<String> hobbys;\n    private Map<String,String> card;\n    private Set<String> games;\n    private String wife;\n    private Properties info;\n```\n\n\n\n3.beans.xml\n\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<beans xmlns=\"http://www.springframework.org/schema/beans\"\n       xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n       xsi:schemaLocation=\"http://www.springframework.org/schema/beans\n        https://www.springframework.org/schema/beans/spring-beans.xsd\">\n    <bean id=\"student\" class=\"com.guoshun.pojo.Student\">\n        <!--第一种:普通值注入,value-->\n        <property name=\"name\" value=\"国顺\"/>\n    </bean>\n</beans>\n```\n\n\n\n4.测试类\n\n```java\npublic class MyTest {\n    public static void main(String[] args) {\n        ApplicationContext Context = new ClassPathXmlApplicationContext(\"beans.xml\");\n        Student student = (Student) Context.getBean(\"student\");\n        System.out.printf( student.getName());\n    }\n}\n\n```\n\n\n\n完善注入信息\n\n```xml\n    <bean id=\"address\" class=\"com.guoshun.pojo.Address\">\n        <property name=\"address\" value=\"长沙\"/>\n    </bean>\n    <bean id=\"student\" class=\"com.guoshun.pojo.Student\">\n        <!--第一种:普通值注入,value-->\n        <property name=\"name\" value=\"国顺\"/>\n        <!--第二种bean注入  ref-->\n        <property name=\"address\" ref=\"address\">\n        </property>\n        <!--数组注入-->\n        <property name=\"books\">\n            <array>\n                <value>红楼梦</value>\n                <value>水浒传</value>\n                <value>三国演义</value>\n                <value>西游记</value>\n            </array>\n        </property>\n        <property name=\"hobbys\">\n            <list>\n                <value>听歌</value>\n            </list>\n        </property>\n        <property name=\"card\">\n            <map>\n                <entry key=\"身份证\" value=\"1125457788\"/>\n                <entry key=\"电话\" value=\"191646551\"/>\n            </map>\n        </property>\n        <property name=\"games\">\n            <set>\n                <value>LOL</value>\n                <value>COC</value>\n                <value>BOB</value>\n            </set>\n        </property>\n        <property name=\"wife\">\n            <null/>\n        </property>\n        <property name=\"info\">\n            <props>\n                <prop key=\"driver\">mysql</prop>\n                <prop key=\"url\">root</prop>\n                <prop key=\"password\">985211</prop>\n            </props>\n        </property>\n    </bean>\n```\n\n\n\n## 6.3、拓展方式注入\n\n我们可以使用P命名空间和c命名空间进行注入\n\n官方解释:\n\n使用!\n\n![1576302934268](C:\\Users\\guosz\\AppData\\Roaming\\Typora\\typora-user-images\\1576302934268.png)\n\n测试:\n\n```java\n   @Test\n    public void test2(){\n        ApplicationContext context = new ClassPathXmlApplicationContext(\"userbeans.xml\");\n        User user = (User) context.getBean(\"user\",User.class);\n        System.out.printf( user.toString());\n    }\n```\n\n\n\n注意点:	命名和c命名空间不能直接使用，需要导入XML约束！\n\n```xml\n xmlns:c=\"http://www.springframework.org/schema/c\"\n xmlns:p=\"http://www.springframework.org/schema/p\"\n```\n\n\n\n## 6.4、Bean的作用域\n\n![1576303696640](C:\\Users\\guosz\\AppData\\Roaming\\Typora\\typora-user-images\\1576303696640.png)\n\n\n\n1.单列模式:(Spring默认机制)\n\n```\n<bean id=\"user\" class=\"com.guoshun.pojo.User\" p:name=\"顺哥\" p:age=\"18\" scope=\"singleton\"/>\n```\n\n2.原型模式:每次从容器中get的时候都会产生一个新的对象\n\n```xml\n<bean id=\"accountService\" class=\"com.something.DefaultAccountService\" scope=\"prototype\"/>\n```\n\n3.其余的:request 、Session 、application  这些个只能在Web开发的\n\n\n\n# 7、Bean的自动装配\n\n- 自动装配是Spring满足bean依赖一种方式\n- Spring会在上下文中自动寻找bean，自动给bean装配属性！\n\n在Spring中有三种装配的方式\n\n​	1.在XML中显示的配置\n\n​	2.在java中显示配置\n\n​	3.隐式的自动装配bean【重要!】\n\n\n\n## 7.1、测试\n\n环境搭建:一个人有两个宠物!\n\n\n\n## 7.2、ByName自动装配\n\n```xml\n <!--\n        byName:会自动在容器上下文中查找，和自己对象set方法后面的值对应的bean id！\n        -->\n        <bean id=\"people\" class=\"com.Gosion.pojo.People\" autowire=\"byName\">\n            <property name=\"name\" value=\"靓仔顺\"/>\n        </bean>\n```\n\n\n\n## 7.3、ByType自动装配\n\n```xml\n  <bean id=\"dog\" class=\"com.Gosion.pojo.Dog\"/>\n        <bean id=\"cacdscmdst\" class=\"com.Gosion.pojo.Cat\"/>\n        <!--\n        byName:会自动在容器上下文中查找，和自己对象set方法后面的值对应的bean id！\n        byType:会自动在容器上下文中查找，和自己对象属性类型相同的bean id!\n        -->\n        <bean id=\"people\" class=\"com.Gosion.pojo.People\" autowire=\"byType\">\n            <property name=\"name\" value=\"靓仔顺\"/>\n        </bean>\n```\n\n\n\n小结：\n\n- byname的时候，需要保证所有bean的id唯一，并且这个bean需要和自动注入的属性的set方法发值一致\n- byType的时候，需要保证bean的class唯一，并且这个bean需要和自动注入的属性的类型一致！\n\n\n\n## 7.4、使用注解实现自动装配\n\njdk1.5支持注解,Spring2.5支持注解了！\n\n The introduction of annotation-based configuration raised the question of whether this approach is “better” than XML. \n\n要使用注解须知:\n\n​		1.导入约束。context约束\n\n​		2.配置注解的支持：==<context:annotation-config/>==【重点】\n\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<beans xmlns=\"http://www.springframework.org/schema/beans\"\n    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n    xmlns:context=\"http://www.springframework.org/schema/context\"\n    xsi:schemaLocation=\"http://www.springframework.org/schema/beans\n        https://www.springframework.org/schema/beans/spring-beans.xsd\n        http://www.springframework.org/schema/context\n        https://www.springframework.org/schema/context/spring-context.xsd\">\n\n    <context:annotation-config/>\n\n</beans>\n```\n\n\n\n**@Autowired**\n\n直接在属性上用即可，也可以在Set上使用！\n\n使用@Autowaired我们可以不用编写set方法了，前提是你这个自动装配的属性在IOC(Spring)容器中存在，且符合byname!\n\n科普:\n\n```xml\n@Nullable	字段标记了这个注解,说明这个字段可以为null；\n```\n\n```java\n    //如果显示定义了Autowired的required的属性为false，说明这个对象可以为null否则为空\n    @Autowired(required = false)\n    private Cat cat;\n    @Autowired\n    private Dog dog;\n    private String name;\n```\n\n\n\n如果@Autowired自动装配的环境比较复杂，自动装配无法通过一个注解【@Autowired】完成的时候、我们可以使用@Qualifier(value=\"xxx\")去配合@Autowired的使用，指定一个唯一的对象bean对象注入！\n\n\n\n**@Resouce注解**\n\n需要导入jar包\n\n![1576327301180](C:\\Users\\guosz\\AppData\\Roaming\\Typora\\typora-user-images\\1576327301180.png)\n\n\n\n小结:\n\n@Resouce和@Autowaired区别:\n\n- 都是用来自动装配的，都可以用来放在属性字段上\n- @Autowired通过byname的方式实现，而且必须要求这个对象存在！【常用】\n- @Resource 默认通过byname方式实现，如果找不到名字则通过bytype实现！如果两个都找不到的情况下就报错！【常用】\n- 执行顺序不同:@Autowired byname实现 \n\n\n\n# 8、使用注解开发\n\n在Spring4之后，要使用注解开发，必须要保证aop的包导入了\n\n![1576459409083](C:\\Users\\guosz\\AppData\\Roaming\\Typora\\typora-user-images\\1576459409083.png)\n\n\n\n使用注解需要导入context约束，增加注解支持！\n\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<beans xmlns=\"http://www.springframework.org/schema/beans\"\n    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n    xmlns:context=\"http://www.springframework.org/schema/context\"\n    xsi:schemaLocation=\"http://www.springframework.org/schema/beans\n        https://www.springframework.org/schema/beans/spring-beans.xsd\n        http://www.springframework.org/schema/context\n        https://www.springframework.org/schema/context/spring-context.xsd\">\n\n    <context:annotation-config/>\n\n</beans>\n```\n\n\n\n1.bean\n\n2.属性如何注入\n\n```java\nimport org.springframework.beans.factory.annotation.Value;\nimport org.springframework.stereotype.Component;\n//等价于 <bean id=\"user\" class=\"com.Gosion.pojo.User\">\n//Component 组件\n@Component\npublic class User {\n    //等价于   <property name=\"name\" value=\"gosion\"/>\n    @Value(\"Gosion\")\n    public String name;\n}\n```\n\n3.衍生的注解\n\n@Component有几个衍生注解，在我们web开发中，会按照mvc三层架构分层!\n\n- ​	dao【@Repository】\n\n- service【@Service】\n\n- controller【@Controller】\n\n  这四个注解功能都是一样的，都是代表某个类注册到Spring容器中，装配Bean\n\n4.自动装配\n\n**上面学过了**\n\n5.作用域\n\n```java\nimport org.springframework.beans.factory.annotation.Value;\nimport org.springframework.context.annotation.Scope;\nimport org.springframework.stereotype.Component;\n//等价于 <bean id=\"user\" class=\"com.Gosion.pojo.User\">\n//Component 组件\n@Component\n@Scope(\"prototype\")\npublic class User {\n    //等价于   <property name=\"name\" value=\"gosion\"/>\n    @Value(\"Gosion\")\n    public String name;\n}\n\n```\n\n \n\n6.小结\n\nxml于注解:\n\n- [ ] xml更加万能,使用任何场合,维护简单方便\n- [ ] 注解不是自己的类使用不了，维护相对复杂\n\nxml与注解最佳实践：\n\n- ​	xml用来管理bean\n- 注解只负责完成属性的注入\n- 我们在使用的过程中，只需要注意一个问题：必须让注解生效，就需要开启注解的支持\n\n```xml\n <!--指定要扫描的包，这个包下的注解就会生效-->\n    <context:component-scan base-package=\"com.Gosion\"/>\n    <context:annotation-config/>\n\n```\n\n\n\n# 9、使用java的方式配置Spring\n\n我们现在完全不要使用Spring的xml配置了，全权交给java来做！\n\njavaConfig 是spring的一个子项目,在Spring4之后它变成了核心功能\n\n![1576474773630](C:\\Users\\guosz\\AppData\\Roaming\\Typora\\typora-user-images\\1576474773630.png)\n\n实体类\n\n```java\nimport org.springframework.beans.factory.annotation.Value;\nimport org.springframework.stereotype.Component;\nimport org.springframework.stereotype.Repository;\n//这里这个注解的意思，就是说这个类被Spring接管了，注册到了容器中\n@Component\npublic class User {\n    private String name;\n\n    public String getName() {\n        return name;\n    }\n    @Value(\"guoshun\")//属性注入值\n    public void setName(String name) {\n        this.name = name;\n    }\n}\n\n```\n\n配置类\n\n```java\npackage com.guoshun.config;\n\nimport com.guoshun.pojo.User;\nimport org.springframework.context.annotation.Bean;\nimport org.springframework.context.annotation.ComponentScan;\nimport org.springframework.context.annotation.Configuration;\n\n// Configuration代表这是一个配置类，就和我们之前看的Beans.xml是一样的\n@Configuration//这个也会被Spring容器托管，注册到容器中，因为他本来就是一个@Component，\n@ComponentScan(\"com.guoshun.pojo\")\npublic class GosionConfig {\n    @Bean//注册一个bean，就相当于我们之前写的一个bean标签，\n    //这个方法的名字，就相当与bean标签中的id属性\n    //这个方法的返回值就相当于bean标签的class属性\n    public User getUser(){\n        return new User();//就是返回要返回要注入的对象！\n    }\n}\n\n```\n\n测试类\n\n```java\nimport com.guoshun.config.GosionConfig;\nimport com.guoshun.pojo.User;\nimport org.springframework.context.ApplicationContext;\nimport org.springframework.context.annotation.AnnotationConfigApplicationContext;\n\npublic class MyTest {\n    public static void main(String[] args) {\n        //如果完全使用了配置类方式去做，我们就只能通过AnnotationConfig上下文来获取容器，通过配置类的Class对象加载！\n        ApplicationContext context = new AnnotationConfigApplicationContext(GosionConfig.class);\n        User getUser = (User) context.getBean(\"getUser\");\n        System.out.println(getUser.getName());\n\n\n    }\n}\n```\n\n\n\n这种纯java配置方式，在SpringBoot中随处可见！\n\n\n\n\n\n# 10、代理模式\n\n为什么学代理模式?因为这是Spring AOP的代理层！【SpringAOP和SpringMVC】\n\n代理模式的分类:\n\n- 静态代理\n- 动态代理\n\n![1576477327663](C:\\Users\\guosz\\AppData\\Roaming\\Typora\\typora-user-images\\1576477327663.png)\n\n\n\n## 10.1、代理模式\n\n角色分析:\n\n- 抽象的角色:一般会使用接口或者抽象类来解决\n- 真是角色:被代理的角色\n- 代理角色：代理真是角色，代理真实角色后，我们一般会做一些附属操作\n- 客户:访问代理对象的人\n\n\n\n代码步骤：\n\n​	1.接口\n\n```java\n//租房\npublic interface Rent {\n    public void rent();\n}\n```\n\n​	2.真实角色\n\n```java\n//房东\npublic class Host  implements Rent{\n    @Override\n    public void rent() {\n        System.out.println(\"房东要出租房子\");\n    }\n}\n```\n\n​	3.代理角色\n\n```java\n//代理\npublic class Proxy implements Rent{\n    private Host host;\n\n    public Proxy() {\n    }\n\n    public Proxy(Host host) {\n        this.host = host;\n    }\n\n    @Override\n    public void rent() {\n        seeHouse();\n        host.rent();\n        hetong();\n        fare();\n    }\n    //看房\n    public void seeHouse(){\n        System.out.println(\"中介带你看房\");\n    }\n    //收中介费\n    public  void hetong(){\n        System.out.println(\"签租赁合同\");\n    }\n    //收中介费\n    public  void fare(){\n        System.out.println(\"收中介费\");\n    }\n}\n```\n\n​	4.客户端访问代理角色\n\n```java\npublic class Client {\n    public static void main(String[] args) {\n        //房东要租房子\n        Host host = new Host();\n        //代理 中介帮房东租房子 但是呢 代理角色一般会有一些附属操作\n        Proxy proxy=new Proxy(host);\n        //你不用面对房东，直接找中介租房即可！\n        proxy.rent();\n    }\n}\n```\n\n\n\n\n\n代理模式的好处：\n\n- 可以使真是角色的操作更加纯粹，不用去关注一些公共的业务\n- 公共业务就交给了代理角色,实现了业务的分工！\n- 公共业务发生扩展的时候，方便集中管理！\n\n缺点:\n\n- 一个真实角色就会产生一个代理角色；代码量会翻倍,开发效率会变低\n\n\n\n## 10.2、加深理解\n\n代码对应 08-练习demo2\n\n聊聊AOP\n\n<img src=\"C:\\Users\\guosz\\AppData\\Roaming\\Typora\\typora-user-images\\1576484746469.png\" alt=\"1576484746469\" style=\"zoom: 67%;\" />\n\n\n\n## 10.3、动态代理\n\n- 动态代理，和静态代理角色一样\n- 动态代理的类是动态生成的，不是我们直接写好的\n- 动态代理分为两大类：基于接口的动态代理,基于类的动\n  - 基于接口----JDK动态代理【我们在这了使用】\n  - 基于类：cglib\n  - java字节码实现：javasist\n\n需要了解两个类：Proxy:代理 ,InvocationHandler：调用处理程序\n\n\n\n动态代理的好处:\n\n- 可以使真是角色的操作更加纯粹，不用去关注一些公共的业务\n- 公共业务就交给了代理角色,实现了业务的分工！\n- 公共业务发生扩展的时候，方便集中管理！\n- 一个动态代理类代理的是一个接口，一般就是对应的一类业务\n- 一个动态代理类可以代理多个类，只要实现了同一个接口即可\n\n\n\n# 11、AOP\n\n## 11.1、什么是AOP?\n\n ，AOP为Aspect Oriented Programming的缩写，意为：[面向切面编程](https://baike.baidu.com/item/面向切面编程/6016335)，通过[预编译](https://baike.baidu.com/item/预编译/3191547)方式和运行期动态代理实现程序功能的统一维护的一种技术。AOP是[OOP](https://baike.baidu.com/item/OOP)的延续，是软件开发中的一个热点，也是[Spring](https://baike.baidu.com/item/Spring)框架中的一个重要内容，是[函数式编程](https://baike.baidu.com/item/函数式编程/4035031)的一种衍生范型。利用AOP可以对业务逻辑的各个部分进行隔离，从而使得业务逻辑各部分之间的[耦合度](https://baike.baidu.com/item/耦合度/2603938)降低，提高程序的可重用性，同时提高了开发的效率。 \n\n\n\n\n\n## 11.2、AOP在Spring中的作用\n\n==提供声明事务；允许用户自定义切面==\n\n- 横切关注点：跨越应用程序多个模块的方法或功能，即使，与我们业务逻辑无关的，但我们需要关注分部分，就是横切关注点。如日志，安全，缓存，事务等等\n- 切面:（ASPECT）：切面关注点被模块化的特殊对象。即它是一个类。\n- 通知:(Advice)切面必须要完成的工作\n- 目标(Target):被通知对象\n- 代理（Proxy）:向目标对象应用通知之后创建的对象\n- 切入点(PointCut):切面通知执行的“地点”的定义\n- 连接点（JointPoint）：与切入点匹配的执行点\n\n![1576545392198](C:\\Users\\guosz\\AppData\\Roaming\\Typora\\typora-user-images\\1576545392198.png)\n\nSpringAOP中，通过Advice定义横切逻辑，Spring中支持5种类型的Advice：\n\n<img src=\"C:\\Users\\guosz\\AppData\\Roaming\\Typora\\typora-user-images\\1576568456067.png\" alt=\"1576568456067\" style=\"zoom:67%;\" />\n\n即Aop在不改变原代码的情况下，去增加新的功能\n\n\n\n## 11.3、使用Spring实现AOP\n\n【重点】使用AOP织入，需要导入一个依赖包！\n\n```xml\n<dependency>\n            <groupId>org.aspectj</groupId>\n            <artifactId>aspectjweaver</artifactId>\n            <version>1.9.4</version>\n</dependency>\n```\n\n\n\n\n\n方式一：使用Spring的APl接口 【主要SpringAPI接口实现】\n\n方式二：自定义来实现AOP 【主要是切面定义】\n\n方式三:使用注解实现\n\n\n\n# 12、整合Mybatis\n\n步骤:\n\n1.导入相关jar包\n\n- ​	junit		\n\n- myvatis\n- mysql数据库的\n- spring相关的\n- aop织入\n- mybatis-spring【new 】\n\n2.编写配置文件\n\n3.测试\n\n\n\n## 12.1、回忆mybatis\n\n1. 编写实体类\n\n   \n\n2. 编写核心配置文件\n\n3. 编写接口\n\n4. 编写Mapper.xml\n\n5. 测试\n\n\n\n## 12.2、mybatis-spring\n\n\n\n1. 编写数据源配置\n\n   ```xml\n       <!--DataSource :使用Spring的数据源替换mybatis的配置\n       我们这里使用Spring提供的JDBC\n       -->\n       <bean id=\"dataSource\" class=\"org.springframework.jdbc.datasource.DriverManagerDataSource\">\n           <property name=\"driverClassName\" value=\"com.mysql.jdbc.Driver\"/>\n           <property name=\"url\" value=\"jdbc:mysql:///mybatis\"/>\n           <property name=\"username\" value=\"root\"/>\n           <property name=\"password\" value=\"985211\"/>\n       </bean>\n   ```\n\n2. SqlSessionFactory\n\n   ```xml\n      <!--SqlSessionFactory-->\n       <bean id=\"sqlSessionFactory\" class=\"org.mybatis.spring.SqlSessionFactoryBean\">\n           <property name=\"dataSource\" ref=\"dataSource\" />\n           <!--绑定Mybatis配置文件-->\n           <property name=\"configLocation\" value=\"classpath:mybatis-config.xml\"/>\n           <property name=\"mapperLocations\" value=\"classpath:com/Gosion/Mapper/UserMapper.xml\"/>\n       </bean>\n   ```\n\n3. SqlSessionTemplate\n\n   ```xml\n       <!--SqlSessionTemplate 就是我们使用的SqlSession-->\n       <bean id=\"SqlSession\" class=\"org.mybatis.spring.SqlSessionTemplate\">\n           <!--只能使用构造器注入，因为他没有set方法-->\n               <constructor-arg index=\"0\" ref=\"sqlSessionFactory\"/>\n       </bean>\n   ```\n\n4. 需要给接口加实现类\n\n   ```java\n   import com.Gosion.pojo.User;\n   import org.mybatis.spring.SqlSessionTemplate;\n   \n   import java.util.List;\n   \n   public class USerMapperImpl  implements UserMapper{\n       private SqlSessionTemplate sqlSession;\n   \n       public void setSqlSession(SqlSessionTemplate sqlSession) {\n           this.sqlSession = sqlSession;\n       }\n   \n       //我们的所有操作，都使用sqlSession来执行，在原来，现在都是使用SqlSessionTemplate\n       public List<User> selectUser() {\n   \n           UserMapper mapper = sqlSession.getMapper(UserMapper.class);\n           return mapper.selectUser();\n       }\n   }\n   \n   ```\n\n5. 将自己写的实现类，注入到spring中\n\n   ```xml\n      <!---->\n       <bean id=\"userMapper\" class=\"com.Gosion.Mapper.USerMapperImpl\">\n           <property name=\"sqlSession\" ref=\"SqlSession\"/>\n       </bean>\n   ```\n\n6. 测试即可\n\n```java\nimport com.Gosion.Mapper.UserMapper;\nimport com.Gosion.pojo.User;\nimport org.junit.Test;\nimport org.springframework.context.ApplicationContext;\nimport org.springframework.context.support.ClassPathXmlApplicationContext;\n\nimport java.io.IOException;\n\npublic class MyTest {\n    @Test\n    public void test() throws IOException {\n       ApplicationContext context = new ClassPathXmlApplicationContext(\"applicationContext.xml\");\n        UserMapper userMapper = context.getBean(\"userMapper\", UserMapper.class);\n        for (User user : userMapper.selectUser()) {\n            System.out.println(user);\n        }\n    }\n}\n```\n\nspring-dao\n\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<beans xmlns=\"http://www.springframework.org/schema/beans\"\n       xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n       xmlns:aop=\"http://www.springframework.org/schema/aop\"\n       xsi:schemaLocation=\"http://www.springframework.org/schema/beans\n        https://www.springframework.org/schema/beans/spring-beans.xsd\n         http://www.springframework.org/schema/aop\n        https://www.springframework.org/schema/aop/spring-aop.xsd\">\n\n  <!--dataSource-->\n    <bean id=\"dataSource\" class=\"org.springframework.jdbc.datasource.DriverManagerDataSource\">\n        <property name=\"driverClassName\" value=\"com.mysql.jdbc.Driver\"/>\n        <property name=\"url\" value=\"jdbc:mysql://localhost:3306/mybatis?serverTimezone=GMT%2B8&amp;useSSL=false\"/>\n        <property name=\"username\" value=\"root\"/>\n        <property name=\"password\" value=\"985211\"/>\n    </bean>\n    <!--SqlSessionFactory-->\n    <bean id=\"sqlSessionFactory\" class=\"org.mybatis.spring.SqlSessionFactoryBean\">\n        <property name=\"dataSource\" ref=\"dataSource\" />\n\n        <property name=\"configLocation\" value=\"classpath:mybatis-config.xml\"/>\n        <property name=\"mapperLocations\" value=\"classpath:com/Gosion/Mapper/UserMapper.xml\"/>\n    </bean>\n    <bean id=\"SqlSession\" class=\"org.mybatis.spring.SqlSessionTemplate\">\n        <constructor-arg index=\"0\" ref=\"sqlSessionFactory\"/>\n    </bean>\n\n    <bean id=\"userMapper\" class=\"com.Gosion.Mapper.UserMapperImpl\">\n        <property name=\"sqlSession\" ref=\"SqlSession\"/>\n    </bean>\n\n</beans>\n```\n\n==整合需要的jar包==\n\n```xml\n<dependencies>\n    <dependency>\n        <groupId>mysql</groupId>\n        <artifactId>mysql-connector-java</artifactId>\n        <version>8.0.11</version>\n    </dependency>\n\n    <dependency>\n        <groupId>org.mybatis</groupId>\n        <artifactId>mybatis</artifactId>\n        <version>3.5.2</version>\n    </dependency>\n\n    <dependency>\n        <groupId>junit</groupId>\n        <artifactId>junit</artifactId>\n        <version>4.12</version>\n    </dependency>\n\n    <dependency>\n        <groupId>org.mybatis</groupId>\n        <artifactId>mybatis-spring</artifactId>\n        <version>2.0.3</version>\n    </dependency>\n\n    <dependency>\n        <groupId>org.springframework</groupId>\n        <artifactId>spring-webmvc</artifactId>\n        <version>5.2.2.RELEASE</version>\n    </dependency>\n\n    <dependency>\n        <groupId>org.springframework</groupId>\n        <artifactId>spring-jdbc</artifactId>\n        <version>5.2.2.RELEASE</version>\n    </dependency>\n    <dependency>\n        <groupId>org.aspectj</groupId>\n        <artifactId>aspectjweaver</artifactId>\n        <version>1.9.4</version>\n    </dependency>\n    <dependency>\n        <groupId>org.projectlombok</groupId>\n        <artifactId>lombok</artifactId>\n        <version>1.18.10</version>\n        <scope>provided</scope>\n    </dependency>\n    <dependency>\n        <groupId>org.springframework</groupId>\n        <artifactId>spring-context</artifactId>\n        <version>5.2.2.RELEASE</version>\n        <scope>test</scope>\n    </dependency>\n</dependencies>\n```\n\n\n\n# 13、声明式事务\n\n\n\n## 1、回顾事务\n\n- 把一组业务当成一个业务来做；要么都成功，要么都失败！\n- 事务在项目开发中十分重要，涉及到数据的一致性问题，不能马虎！\n- 确保完整性，和一致性；\n\n\n\n事务的ACID原则:\n\n- 原子性\n- 一致性\n- 隔离性\n  - 多个业务可能操作同一个资源，防止数据损坏\n- 持久性\n  - 事务一旦提交，无论系统出什么问题，结果都不会再被影响，被持久化的写到存储器中!\n\n## 2、Spring中的事务管理\n\n- 声明式事务：AOP\n- 编程式事务：需要在代码中，进行事务的管理\n\n思考:\n\n为什么需要事务?\n\n- 如果不配置事务，可能存在数据提交不一致的情况下；\n- 如果我们不在Sping中去声明事务，我门就需要在代码中手动配置事务！\n- 事务在项目的开发中十分重要，设计到一致性和完整性问题，不容马虎\n\n\n\n\n\n\n\n\n\n', NULL, 0, 0, 0, NULL, '2020-12-23', 320, NULL, 101);
INSERT INTO `tb_article` VALUES (23, 20, 'mybatus', '', '1 Spring     1 1简介  - Spring 春天---------- 给原件行业带来春天 - 2002 首次推出了Spring框架雏形 interface21框架 - 2004年3月24号Spring发布了1 0正式版 - Rod Johnson   Spring Framework创始人  著名作者  很难想象Rod Johnson的学历 真的让好多人大吃一惊 他是 悉尼大学  https   baike baidu com item 悉尼大学 的博士 然而他的专业不是计算机 而是音乐学   - Spring理念 使现有的技术更加容易使用 本身是一个大杂烩 整合了现有的技术框架', '', '\n\n\n\n# 1、Spring\n\n## 1.1简介\n\n- Spring：春天---------->给原件行业带来春天\n- 2002,首次推出了Spring框架雏形:interface21框架\n- 2004年3月24号Spring发布了1.0正式版\n- Rod Johnson ， Spring Framework创始人 ，著名作者。 很难想象Rod Johnson的学历，真的让好多人大吃一惊，他是[悉尼大学](https://baike.baidu.com/item/悉尼大学)的博士，然而他的专业不是计算机，而是音乐学。 \n- Spring理念：使现有的技术更加容易使用，本身是一个大杂烩，整合了现有的技术框架！\n\n\n\n- SSH :	Struct2+Spring+Hibernate!\n- SSM：  SpringMVC+Spring+Mybatis!\n\n- 官网: https://spring.io/projects/spring-framework \n- 官方下载地址: [http://repo.spring.io/release/org/springframework/spring](https://repo.spring.io/release/org/springframework/spring)  \n- GitHub: https://github.com/spring-projects/spring-framework \n\n```xml\n<!-- https://mvnrepository.com/artifact/org.springframework/spring-webmvc -->\n<dependency>\n    <groupId>org.springframework</groupId>\n    <artifactId>spring-webmvc</artifactId>\n    <version>5.2.0.RELEASE</version>\n</dependency>\n<!-- https://mvnrepository.com/artifact/org.springframework/spring-webmvc -->\n<dependency>\n    <groupId>org.springframework</groupId>\n    <artifactId>spring-jdbc</artifactId>\n    <version>5.2.0.RELEASE</version>\n</dependency>\n```\n\n\n\n## 1.2、优点\n\n- Spring是一个开源的免费的框架(容器)！\n- Spring是一个轻量级的、非入侵 式的框架！\n- 控制反转(IOC)，面向切面编程(AOP)！\n- 支持事务的处理，对框架整合的支持！\n\n==总结一句话:Spring就是一个轻量级的控制反转(IOC)和面向切面编程（AOP）的框架！==\n\n\n\n## 1.3组成\n\n![1576133682226](C:\\Users\\guosz\\AppData\\Roaming\\Typora\\typora-user-images\\1576133682226.png)\n\n\n\n## 1.4拓展\n\n在Spring的官网有这个介绍:现代化的java开发!说白就是基于Spring的开发\n\n![1576133880492](C:\\Users\\guosz\\AppData\\Roaming\\Typora\\typora-user-images\\1576133880492.png)\n\n\n\n- Spring Boot\n  - 快速开发的脚手架。\n  - 基于Spring Boot可以快速的开发单个微服务。\n  - 约定大于配置！\n- Spring Cloud\n  - Spring Cloud是基于Spring Boot实现的\n\n因为现在大多数公司都在使用Spring Boot进行快速开发，学习Spring Boot的前提，需要完全掌握Spring及Spring MVC!承上启下的作用!\n\n\n\n**弊端:发展了太久之后,违背了原来的理念!配置十分繁琐，人称配置地狱**\n\n\n\n# 2、IOC理论推导\n\n1.UserDao接口\n\n2.UserDaoImpl实现类\n\n3.UserService业务接口\n\n4.UserServiceImpl 业务实现类\n\n\n\n在我们之前的业务中，用户的需求可能会影响我们原来的代码，我们需要根据用户的需求去修改原代码！如果程序代码量十分大，修改一次的成本代价十分昂贵！\n\n![1576217867883](C:\\Users\\guosz\\AppData\\Roaming\\Typora\\typora-user-images\\1576217867883.png)\n\n我们使用一个Set接口实现. 已经发生了革命性的变化\n\n```java\n private UserDao userDao;\n    //利用set进行动态实现值的注入\n    public  void setUserDao(UserDao userDao) {\n        this.userDao = userDao;\n    }\n```\n\n- 之前，程序是主动创建对象！控制权在程序员手上！\n- 使用set注入后，程序不在具有主动性，而是变成了被动的接受对象!\n\n这种思想，从本质上解决了问题，我们程序员不用再去管理对象的创建了。系统的耦合性大大将达~，可以更加专注的在业务的实现！这是IOC的原型\n\n\n\n![1576217839709](C:\\Users\\guosz\\AppData\\Roaming\\Typora\\typora-user-images\\1576217839709.png)\n\n\n\n\n\n##  IOC本质\n\n控制反转IoC(Inversion of Control)，是一种设计思想，DI(依赖注入)是实现IoC的一种方法**，也有人认为DI只是IoC的另一种说法。没有IoC的程序中 , 我们使用面向对象编程 , 对象的创建与对象间的依赖关系完全硬编码在程序中，对象的创建由程序自己控制，控制反转后将对象的创建转移给第三方，个人认为所谓控制反转就是：获得依赖对象的方式反转了。 \n\n\n\n 采用XML方式配置Bean的时候，Bean的定义信息是和实现分离的，而采用注解的方式可以把两者合为一体，Bean的定义信息直接以注解的形式定义在实现类中，从而达到了零配置的目的。 \n\n **控制反转是一种通过描述（XML或注解）并通过第三方去生产或获取特定对象的方式。在Spring中实现控制反转的是IoC容器，其实现方法是依赖注入（Dependency Injection,DI）。** \n\n\n\n# 3、HelloSpring\n\n## 1.导入Spring相关的jar包\n\n注 : spring 需要导入commons-logging进行日志记录 . 我们利用maven , 他会自动下载对应的依赖项 .\n\n```xml\n<dependency>\n    <groupId>org.springframework</groupId>\n    <artifactId>spring-webmvc</artifactId>\n    <version>5.1.10.RELEASE</version>\n</dependency>\n```\n\n \n\n## 2.编写相关代码\n\n```java\n public class Hello {\n     private String name;\n \n     public String getName() {\n         return name;\n     }\n     public void setName(String name) {\n         this.name = name;\n     }\n \n     public void show(){\n         System.out.println(\"Hello\"+ name );\n     }\n }\n```\n\n \n\n2.2 写编写我们的spring文件 , 这里我们命名为beans.xml\n\n```xml\n   <?xml version=\"1.0\" encoding=\"UTF-8\"?>\n   <beans xmlns=\"http://www.springframework.org/schema/beans\"\n          xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n          xsi:schemaLocation=\"http://www.springframework.org/schema/beans\n           http://www.springframework.org/schema/beans/spring-beans.xsd\">\n   \n       <!--bean就是java对象 , 由Spring创建和管理-->\n       <bean id=\"hello\" class=\"com.kuang.pojo.Hello\">\n          <property name=\"name\" value=\"Spring\"/>\n      </bean>\n  \n  </beans>\n```\n\n \n\n2.3 我们可以去进行测试了 \n\n```java\n @Test\n public void test(){\n     //解析beans.xml文件 , 生成管理相应的Bean对象\n     ApplicationContext context = newClassPathXmlApplicationContext(\"beans.xml\");\n     //getBean : 参数即为spring配置文件中bean的id .\n     Hello hello = (Hello) context.getBean(\"hello\");\n     hello.show();\n }\n```\n\n \n\n### 思考问题 ?\n\n- Hello 对象是谁创建的 ?\n\n  hello 对象是由Spring创建的\n\n- Hello 对象的属性是怎么设置的 ?\n\n  hello 对象的属性是由Spring容器设置的 ,\n\n这个过程就叫控制反转 :\n\n控制 : 谁来控制对象的创建 , 传统应用程序的对象是由程序本身控制创建的 , 使用Spring后 , 对象是由Spring来创建的 .\n\n反转 : 程序本身不创建对象 , 而变成被动的接收对象 .\n\n依赖注入 : 就是利用set方法来进行注入的.\n\nIOC是一种编程思想 , 由主动的编程变成被动的接收 .\n\n可以通过newClassPathXmlApplicationContext去浏览一下底层源码 .\n\n**OK , 到了现在 , 我们彻底不用再程序中去改动了 , 要实现不同的操作 , 只需要在xml配置文件中进行修改 , 所谓的IoC,一句话搞定 : 对象由Spring 来创建 , 管理 , 装配 !**\n\n\n\n# 4.IOC创建对象的方式\n\n1.使用无惨构造创建对象，默认！\n\n2.假设我了吧要使用有参构造创建对象\n\n## 	1.下标赋值\n\n```xml\n<!--第一种下标赋值-->\n<bean id=\"user\" class=\"com.Gosion.pojo.User\">    \n    <constructor-arg index=\"0\" value=\"Gosion学java\"/>\n</bean>\n```\n\n## 	2.类型\n\n```xml\n<!--第二种方式:通过类型创建,不建议使用-->\n    <bean id=\"user\" class=\"com.Gosion.pojo.User\">\n        <constructor-arg type=\"java.lang.String\" value=\"国顺\"/>\n    </bean>\n```\n\n## 	3.通过参数名赋值\n\n```xml\n  <!--第三种 : 直接通过参数名来设置-->\n    <bean id=\"user\" class=\"com.Gosion.pojo.User\">\n        <constructor-arg name=\"name\" value=\"Guoshun\"/>\n    </bean>\n```\n\n\n\n总结:在配置文件中加载的时候，容器中管理的对象就已经初始化了！\n\n\n\n# 5、Spring配置\n\n## 5.1、别名\n\n```xml\n<!--别名,如果添加了别名，我们也可以使用别名来获取这个对象-->\n    <alias name=\"user\" alias=\"usernew\"/>\n```\n\n\n\n## 5.2、Bean的配置\n\n```xml\n    <!--\n    id:bean的唯一标识符，也就是相当于我们学的对象名\n    class:bean  对象所对应的全限定名:包名+类名\n    name: 也是别名,而且name可以同时取多个别名\n    -->\n    <bean id=\"userT\" class=\"com.Gosion.pojo.UserT\" name=\"userT2\">\n\n    </bean>\n```\n\n\n\n\n\n## 5.3 、import\n\n这个import，一般用于团队开发使用，他可以将多个配置文件\n\n假设，现在项目中有多个人开发，这三个人负责不同的类开发，不同的类需要注册在不同的bean中，我们可以利用import将所有人的beans.xml合并为总的！\n\n- 张三\n- 李四\n- 王五\n- applicationContext.xml\n\n```.xml\n <import resource=\"beans.xml\"/>\n    <import resource=\"beans2.xml\"/>\n```\n\n\n\n使用的时候，直接使用中的配置就可以了\n\n\n\n# 6、依赖注入\n\n\n\n## 6.1、构造器注入\n\n前面已经说过了\n\n\n\n## 6.2、Set方式注入【重点】\n\n- 依赖注入:set注入！\n  - 依赖：bean对象的创建依赖于容器\n  - 注入:   bean对象中的所有属性，由容器来注入\n\n\n\n【环境搭建】\n\n​	1.复杂类型\n\n```java\npublic class Address {\n    private String address;\n\n    public String getAddress() {\n        return address;\n    }\n\n    public void setAddress(String address) {\n        this.address = address;\n    }\n}\n```\n\n\n\n​	2.真实测试对象\n\n```java\npublic class Student {\n    private String name;\n    private Address address;\n    private String[] books;\n    private List<String> hobbys;\n    private Map<String,String> card;\n    private Set<String> games;\n    private String wife;\n    private Properties info;\n```\n\n\n\n3.beans.xml\n\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<beans xmlns=\"http://www.springframework.org/schema/beans\"\n       xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n       xsi:schemaLocation=\"http://www.springframework.org/schema/beans\n        https://www.springframework.org/schema/beans/spring-beans.xsd\">\n    <bean id=\"student\" class=\"com.guoshun.pojo.Student\">\n        <!--第一种:普通值注入,value-->\n        <property name=\"name\" value=\"国顺\"/>\n    </bean>\n</beans>\n```\n\n\n\n4.测试类\n\n```java\npublic class MyTest {\n    public static void main(String[] args) {\n        ApplicationContext Context = new ClassPathXmlApplicationContext(\"beans.xml\");\n        Student student = (Student) Context.getBean(\"student\");\n        System.out.printf( student.getName());\n    }\n}\n\n```\n\n\n\n完善注入信息\n\n```xml\n    <bean id=\"address\" class=\"com.guoshun.pojo.Address\">\n        <property name=\"address\" value=\"长沙\"/>\n    </bean>\n    <bean id=\"student\" class=\"com.guoshun.pojo.Student\">\n        <!--第一种:普通值注入,value-->\n        <property name=\"name\" value=\"国顺\"/>\n        <!--第二种bean注入  ref-->\n        <property name=\"address\" ref=\"address\">\n        </property>\n        <!--数组注入-->\n        <property name=\"books\">\n            <array>\n                <value>红楼梦</value>\n                <value>水浒传</value>\n                <value>三国演义</value>\n                <value>西游记</value>\n            </array>\n        </property>\n        <property name=\"hobbys\">\n            <list>\n                <value>听歌</value>\n            </list>\n        </property>\n        <property name=\"card\">\n            <map>\n                <entry key=\"身份证\" value=\"1125457788\"/>\n                <entry key=\"电话\" value=\"191646551\"/>\n            </map>\n        </property>\n        <property name=\"games\">\n            <set>\n                <value>LOL</value>\n                <value>COC</value>\n                <value>BOB</value>\n            </set>\n        </property>\n        <property name=\"wife\">\n            <null/>\n        </property>\n        <property name=\"info\">\n            <props>\n                <prop key=\"driver\">mysql</prop>\n                <prop key=\"url\">root</prop>\n                <prop key=\"password\">985211</prop>\n            </props>\n        </property>\n    </bean>\n```\n\n\n\n## 6.3、拓展方式注入\n\n我们可以使用P命名空间和c命名空间进行注入\n\n官方解释:\n\n使用!\n\n![1576302934268](C:\\Users\\guosz\\AppData\\Roaming\\Typora\\typora-user-images\\1576302934268.png)\n\n测试:\n\n```java\n   @Test\n    public void test2(){\n        ApplicationContext context = new ClassPathXmlApplicationContext(\"userbeans.xml\");\n        User user = (User) context.getBean(\"user\",User.class);\n        System.out.printf( user.toString());\n    }\n```\n\n\n\n注意点:	命名和c命名空间不能直接使用，需要导入XML约束！\n\n```xml\n xmlns:c=\"http://www.springframework.org/schema/c\"\n xmlns:p=\"http://www.springframework.org/schema/p\"\n```\n\n\n\n## 6.4、Bean的作用域\n\n![1576303696640](C:\\Users\\guosz\\AppData\\Roaming\\Typora\\typora-user-images\\1576303696640.png)\n\n\n\n1.单列模式:(Spring默认机制)\n\n```\n<bean id=\"user\" class=\"com.guoshun.pojo.User\" p:name=\"顺哥\" p:age=\"18\" scope=\"singleton\"/>\n```\n\n2.原型模式:每次从容器中get的时候都会产生一个新的对象\n\n```xml\n<bean id=\"accountService\" class=\"com.something.DefaultAccountService\" scope=\"prototype\"/>\n```\n\n3.其余的:request 、Session 、application  这些个只能在Web开发的\n\n\n\n# 7、Bean的自动装配\n\n- 自动装配是Spring满足bean依赖一种方式\n- Spring会在上下文中自动寻找bean，自动给bean装配属性！\n\n在Spring中有三种装配的方式\n\n​	1.在XML中显示的配置\n\n​	2.在java中显示配置\n\n​	3.隐式的自动装配bean【重要!】\n\n\n\n## 7.1、测试\n\n环境搭建:一个人有两个宠物!\n\n\n\n## 7.2、ByName自动装配\n\n```xml\n <!--\n        byName:会自动在容器上下文中查找，和自己对象set方法后面的值对应的bean id！\n        -->\n        <bean id=\"people\" class=\"com.Gosion.pojo.People\" autowire=\"byName\">\n            <property name=\"name\" value=\"靓仔顺\"/>\n        </bean>\n```\n\n\n\n## 7.3、ByType自动装配\n\n```xml\n  <bean id=\"dog\" class=\"com.Gosion.pojo.Dog\"/>\n        <bean id=\"cacdscmdst\" class=\"com.Gosion.pojo.Cat\"/>\n        <!--\n        byName:会自动在容器上下文中查找，和自己对象set方法后面的值对应的bean id！\n        byType:会自动在容器上下文中查找，和自己对象属性类型相同的bean id!\n        -->\n        <bean id=\"people\" class=\"com.Gosion.pojo.People\" autowire=\"byType\">\n            <property name=\"name\" value=\"靓仔顺\"/>\n        </bean>\n```\n\n\n\n小结：\n\n- byname的时候，需要保证所有bean的id唯一，并且这个bean需要和自动注入的属性的set方法发值一致\n- byType的时候，需要保证bean的class唯一，并且这个bean需要和自动注入的属性的类型一致！\n\n\n\n## 7.4、使用注解实现自动装配\n\njdk1.5支持注解,Spring2.5支持注解了！\n\n The introduction of annotation-based configuration raised the question of whether this approach is “better” than XML. \n\n要使用注解须知:\n\n​		1.导入约束。context约束\n\n​		2.配置注解的支持：==<context:annotation-config/>==【重点】\n\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<beans xmlns=\"http://www.springframework.org/schema/beans\"\n    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n    xmlns:context=\"http://www.springframework.org/schema/context\"\n    xsi:schemaLocation=\"http://www.springframework.org/schema/beans\n        https://www.springframework.org/schema/beans/spring-beans.xsd\n        http://www.springframework.org/schema/context\n        https://www.springframework.org/schema/context/spring-context.xsd\">\n\n    <context:annotation-config/>\n\n</beans>\n```\n\n\n\n**@Autowired**\n\n直接在属性上用即可，也可以在Set上使用！\n\n使用@Autowaired我们可以不用编写set方法了，前提是你这个自动装配的属性在IOC(Spring)容器中存在，且符合byname!\n\n科普:\n\n```xml\n@Nullable	字段标记了这个注解,说明这个字段可以为null；\n```\n\n```java\n    //如果显示定义了Autowired的required的属性为false，说明这个对象可以为null否则为空\n    @Autowired(required = false)\n    private Cat cat;\n    @Autowired\n    private Dog dog;\n    private String name;\n```\n\n\n\n如果@Autowired自动装配的环境比较复杂，自动装配无法通过一个注解【@Autowired】完成的时候、我们可以使用@Qualifier(value=\"xxx\")去配合@Autowired的使用，指定一个唯一的对象bean对象注入！\n\n\n\n**@Resouce注解**\n\n需要导入jar包\n\n![1576327301180](C:\\Users\\guosz\\AppData\\Roaming\\Typora\\typora-user-images\\1576327301180.png)\n\n\n\n小结:\n\n@Resouce和@Autowaired区别:\n\n- 都是用来自动装配的，都可以用来放在属性字段上\n- @Autowired通过byname的方式实现，而且必须要求这个对象存在！【常用】\n- @Resource 默认通过byname方式实现，如果找不到名字则通过bytype实现！如果两个都找不到的情况下就报错！【常用】\n- 执行顺序不同:@Autowired byname实现 \n\n\n\n# 8、使用注解开发\n\n在Spring4之后，要使用注解开发，必须要保证aop的包导入了\n\n![1576459409083](C:\\Users\\guosz\\AppData\\Roaming\\Typora\\typora-user-images\\1576459409083.png)\n\n\n\n使用注解需要导入context约束，增加注解支持！\n\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<beans xmlns=\"http://www.springframework.org/schema/beans\"\n    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n    xmlns:context=\"http://www.springframework.org/schema/context\"\n    xsi:schemaLocation=\"http://www.springframework.org/schema/beans\n        https://www.springframework.org/schema/beans/spring-beans.xsd\n        http://www.springframework.org/schema/context\n        https://www.springframework.org/schema/context/spring-context.xsd\">\n\n    <context:annotation-config/>\n\n</beans>\n```\n\n\n\n1.bean\n\n2.属性如何注入\n\n```java\nimport org.springframework.beans.factory.annotation.Value;\nimport org.springframework.stereotype.Component;\n//等价于 <bean id=\"user\" class=\"com.Gosion.pojo.User\">\n//Component 组件\n@Component\npublic class User {\n    //等价于   <property name=\"name\" value=\"gosion\"/>\n    @Value(\"Gosion\")\n    public String name;\n}\n```\n\n3.衍生的注解\n\n@Component有几个衍生注解，在我们web开发中，会按照mvc三层架构分层!\n\n- ​	dao【@Repository】\n\n- service【@Service】\n\n- controller【@Controller】\n\n  这四个注解功能都是一样的，都是代表某个类注册到Spring容器中，装配Bean\n\n4.自动装配\n\n**上面学过了**\n\n5.作用域\n\n```java\nimport org.springframework.beans.factory.annotation.Value;\nimport org.springframework.context.annotation.Scope;\nimport org.springframework.stereotype.Component;\n//等价于 <bean id=\"user\" class=\"com.Gosion.pojo.User\">\n//Component 组件\n@Component\n@Scope(\"prototype\")\npublic class User {\n    //等价于   <property name=\"name\" value=\"gosion\"/>\n    @Value(\"Gosion\")\n    public String name;\n}\n\n```\n\n \n\n6.小结\n\nxml于注解:\n\n- [ ] xml更加万能,使用任何场合,维护简单方便\n- [ ] 注解不是自己的类使用不了，维护相对复杂\n\nxml与注解最佳实践：\n\n- ​	xml用来管理bean\n- 注解只负责完成属性的注入\n- 我们在使用的过程中，只需要注意一个问题：必须让注解生效，就需要开启注解的支持\n\n```xml\n <!--指定要扫描的包，这个包下的注解就会生效-->\n    <context:component-scan base-package=\"com.Gosion\"/>\n    <context:annotation-config/>\n\n```\n\n\n\n# 9、使用java的方式配置Spring\n\n我们现在完全不要使用Spring的xml配置了，全权交给java来做！\n\njavaConfig 是spring的一个子项目,在Spring4之后它变成了核心功能\n\n![1576474773630](C:\\Users\\guosz\\AppData\\Roaming\\Typora\\typora-user-images\\1576474773630.png)\n\n实体类\n\n```java\nimport org.springframework.beans.factory.annotation.Value;\nimport org.springframework.stereotype.Component;\nimport org.springframework.stereotype.Repository;\n//这里这个注解的意思，就是说这个类被Spring接管了，注册到了容器中\n@Component\npublic class User {\n    private String name;\n\n    public String getName() {\n        return name;\n    }\n    @Value(\"guoshun\")//属性注入值\n    public void setName(String name) {\n        this.name = name;\n    }\n}\n\n```\n\n配置类\n\n```java\npackage com.guoshun.config;\n\nimport com.guoshun.pojo.User;\nimport org.springframework.context.annotation.Bean;\nimport org.springframework.context.annotation.ComponentScan;\nimport org.springframework.context.annotation.Configuration;\n\n// Configuration代表这是一个配置类，就和我们之前看的Beans.xml是一样的\n@Configuration//这个也会被Spring容器托管，注册到容器中，因为他本来就是一个@Component，\n@ComponentScan(\"com.guoshun.pojo\")\npublic class GosionConfig {\n    @Bean//注册一个bean，就相当于我们之前写的一个bean标签，\n    //这个方法的名字，就相当与bean标签中的id属性\n    //这个方法的返回值就相当于bean标签的class属性\n    public User getUser(){\n        return new User();//就是返回要返回要注入的对象！\n    }\n}\n\n```\n\n测试类\n\n```java\nimport com.guoshun.config.GosionConfig;\nimport com.guoshun.pojo.User;\nimport org.springframework.context.ApplicationContext;\nimport org.springframework.context.annotation.AnnotationConfigApplicationContext;\n\npublic class MyTest {\n    public static void main(String[] args) {\n        //如果完全使用了配置类方式去做，我们就只能通过AnnotationConfig上下文来获取容器，通过配置类的Class对象加载！\n        ApplicationContext context = new AnnotationConfigApplicationContext(GosionConfig.class);\n        User getUser = (User) context.getBean(\"getUser\");\n        System.out.println(getUser.getName());\n\n\n    }\n}\n```\n\n\n\n这种纯java配置方式，在SpringBoot中随处可见！\n\n\n\n\n\n# 10、代理模式\n\n为什么学代理模式?因为这是Spring AOP的代理层！【SpringAOP和SpringMVC】\n\n代理模式的分类:\n\n- 静态代理\n- 动态代理\n\n![1576477327663](C:\\Users\\guosz\\AppData\\Roaming\\Typora\\typora-user-images\\1576477327663.png)\n\n\n\n## 10.1、代理模式\n\n角色分析:\n\n- 抽象的角色:一般会使用接口或者抽象类来解决\n- 真是角色:被代理的角色\n- 代理角色：代理真是角色，代理真实角色后，我们一般会做一些附属操作\n- 客户:访问代理对象的人\n\n\n\n代码步骤：\n\n​	1.接口\n\n```java\n//租房\npublic interface Rent {\n    public void rent();\n}\n```\n\n​	2.真实角色\n\n```java\n//房东\npublic class Host  implements Rent{\n    @Override\n    public void rent() {\n        System.out.println(\"房东要出租房子\");\n    }\n}\n```\n\n​	3.代理角色\n\n```java\n//代理\npublic class Proxy implements Rent{\n    private Host host;\n\n    public Proxy() {\n    }\n\n    public Proxy(Host host) {\n        this.host = host;\n    }\n\n    @Override\n    public void rent() {\n        seeHouse();\n        host.rent();\n        hetong();\n        fare();\n    }\n    //看房\n    public void seeHouse(){\n        System.out.println(\"中介带你看房\");\n    }\n    //收中介费\n    public  void hetong(){\n        System.out.println(\"签租赁合同\");\n    }\n    //收中介费\n    public  void fare(){\n        System.out.println(\"收中介费\");\n    }\n}\n```\n\n​	4.客户端访问代理角色\n\n```java\npublic class Client {\n    public static void main(String[] args) {\n        //房东要租房子\n        Host host = new Host();\n        //代理 中介帮房东租房子 但是呢 代理角色一般会有一些附属操作\n        Proxy proxy=new Proxy(host);\n        //你不用面对房东，直接找中介租房即可！\n        proxy.rent();\n    }\n}\n```\n\n\n\n\n\n代理模式的好处：\n\n- 可以使真是角色的操作更加纯粹，不用去关注一些公共的业务\n- 公共业务就交给了代理角色,实现了业务的分工！\n- 公共业务发生扩展的时候，方便集中管理！\n\n缺点:\n\n- 一个真实角色就会产生一个代理角色；代码量会翻倍,开发效率会变低\n\n\n\n## 10.2、加深理解\n\n代码对应 08-练习demo2\n\n聊聊AOP\n\n<img src=\"C:\\Users\\guosz\\AppData\\Roaming\\Typora\\typora-user-images\\1576484746469.png\" alt=\"1576484746469\" style=\"zoom: 67%;\" />\n\n\n\n## 10.3、动态代理\n\n- 动态代理，和静态代理角色一样\n- 动态代理的类是动态生成的，不是我们直接写好的\n- 动态代理分为两大类：基于接口的动态代理,基于类的动\n  - 基于接口----JDK动态代理【我们在这了使用】\n  - 基于类：cglib\n  - java字节码实现：javasist\n\n需要了解两个类：Proxy:代理 ,InvocationHandler：调用处理程序\n\n\n\n动态代理的好处:\n\n- 可以使真是角色的操作更加纯粹，不用去关注一些公共的业务\n- 公共业务就交给了代理角色,实现了业务的分工！\n- 公共业务发生扩展的时候，方便集中管理！\n- 一个动态代理类代理的是一个接口，一般就是对应的一类业务\n- 一个动态代理类可以代理多个类，只要实现了同一个接口即可\n\n\n\n# 11、AOP\n\n## 11.1、什么是AOP?\n\n ，AOP为Aspect Oriented Programming的缩写，意为：[面向切面编程](https://baike.baidu.com/item/面向切面编程/6016335)，通过[预编译](https://baike.baidu.com/item/预编译/3191547)方式和运行期动态代理实现程序功能的统一维护的一种技术。AOP是[OOP](https://baike.baidu.com/item/OOP)的延续，是软件开发中的一个热点，也是[Spring](https://baike.baidu.com/item/Spring)框架中的一个重要内容，是[函数式编程](https://baike.baidu.com/item/函数式编程/4035031)的一种衍生范型。利用AOP可以对业务逻辑的各个部分进行隔离，从而使得业务逻辑各部分之间的[耦合度](https://baike.baidu.com/item/耦合度/2603938)降低，提高程序的可重用性，同时提高了开发的效率。 \n\n\n\n\n\n## 11.2、AOP在Spring中的作用\n\n==提供声明事务；允许用户自定义切面==\n\n- 横切关注点：跨越应用程序多个模块的方法或功能，即使，与我们业务逻辑无关的，但我们需要关注分部分，就是横切关注点。如日志，安全，缓存，事务等等\n- 切面:（ASPECT）：切面关注点被模块化的特殊对象。即它是一个类。\n- 通知:(Advice)切面必须要完成的工作\n- 目标(Target):被通知对象\n- 代理（Proxy）:向目标对象应用通知之后创建的对象\n- 切入点(PointCut):切面通知执行的“地点”的定义\n- 连接点（JointPoint）：与切入点匹配的执行点\n\n![1576545392198](C:\\Users\\guosz\\AppData\\Roaming\\Typora\\typora-user-images\\1576545392198.png)\n\nSpringAOP中，通过Advice定义横切逻辑，Spring中支持5种类型的Advice：\n\n<img src=\"C:\\Users\\guosz\\AppData\\Roaming\\Typora\\typora-user-images\\1576568456067.png\" alt=\"1576568456067\" style=\"zoom:67%;\" />\n\n即Aop在不改变原代码的情况下，去增加新的功能\n\n\n\n## 11.3、使用Spring实现AOP\n\n【重点】使用AOP织入，需要导入一个依赖包！\n\n```xml\n<dependency>\n            <groupId>org.aspectj</groupId>\n            <artifactId>aspectjweaver</artifactId>\n            <version>1.9.4</version>\n</dependency>\n```\n\n\n\n\n\n方式一：使用Spring的APl接口 【主要SpringAPI接口实现】\n\n方式二：自定义来实现AOP 【主要是切面定义】\n\n方式三:使用注解实现\n\n\n\n# 12、整合Mybatis\n\n步骤:\n\n1.导入相关jar包\n\n- ​	junit		\n\n- myvatis\n- mysql数据库的\n- spring相关的\n- aop织入\n- mybatis-spring【new 】\n\n2.编写配置文件\n\n3.测试\n\n\n\n## 12.1、回忆mybatis\n\n1. 编写实体类\n\n   \n\n2. 编写核心配置文件\n\n3. 编写接口\n\n4. 编写Mapper.xml\n\n5. 测试\n\n\n\n## 12.2、mybatis-spring\n\n\n\n1. 编写数据源配置\n\n   ```xml\n       <!--DataSource :使用Spring的数据源替换mybatis的配置\n       我们这里使用Spring提供的JDBC\n       -->\n       <bean id=\"dataSource\" class=\"org.springframework.jdbc.datasource.DriverManagerDataSource\">\n           <property name=\"driverClassName\" value=\"com.mysql.jdbc.Driver\"/>\n           <property name=\"url\" value=\"jdbc:mysql:///mybatis\"/>\n           <property name=\"username\" value=\"root\"/>\n           <property name=\"password\" value=\"985211\"/>\n       </bean>\n   ```\n\n2. SqlSessionFactory\n\n   ```xml\n      <!--SqlSessionFactory-->\n       <bean id=\"sqlSessionFactory\" class=\"org.mybatis.spring.SqlSessionFactoryBean\">\n           <property name=\"dataSource\" ref=\"dataSource\" />\n           <!--绑定Mybatis配置文件-->\n           <property name=\"configLocation\" value=\"classpath:mybatis-config.xml\"/>\n           <property name=\"mapperLocations\" value=\"classpath:com/Gosion/Mapper/UserMapper.xml\"/>\n       </bean>\n   ```\n\n3. SqlSessionTemplate\n\n   ```xml\n       <!--SqlSessionTemplate 就是我们使用的SqlSession-->\n       <bean id=\"SqlSession\" class=\"org.mybatis.spring.SqlSessionTemplate\">\n           <!--只能使用构造器注入，因为他没有set方法-->\n               <constructor-arg index=\"0\" ref=\"sqlSessionFactory\"/>\n       </bean>\n   ```\n\n4. 需要给接口加实现类\n\n   ```java\n   import com.Gosion.pojo.User;\n   import org.mybatis.spring.SqlSessionTemplate;\n   \n   import java.util.List;\n   \n   public class USerMapperImpl  implements UserMapper{\n       private SqlSessionTemplate sqlSession;\n   \n       public void setSqlSession(SqlSessionTemplate sqlSession) {\n           this.sqlSession = sqlSession;\n       }\n   \n       //我们的所有操作，都使用sqlSession来执行，在原来，现在都是使用SqlSessionTemplate\n       public List<User> selectUser() {\n   \n           UserMapper mapper = sqlSession.getMapper(UserMapper.class);\n           return mapper.selectUser();\n       }\n   }\n   \n   ```\n\n5. 将自己写的实现类，注入到spring中\n\n   ```xml\n      <!---->\n       <bean id=\"userMapper\" class=\"com.Gosion.Mapper.USerMapperImpl\">\n           <property name=\"sqlSession\" ref=\"SqlSession\"/>\n       </bean>\n   ```\n\n6. 测试即可\n\n```java\nimport com.Gosion.Mapper.UserMapper;\nimport com.Gosion.pojo.User;\nimport org.junit.Test;\nimport org.springframework.context.ApplicationContext;\nimport org.springframework.context.support.ClassPathXmlApplicationContext;\n\nimport java.io.IOException;\n\npublic class MyTest {\n    @Test\n    public void test() throws IOException {\n       ApplicationContext context = new ClassPathXmlApplicationContext(\"applicationContext.xml\");\n        UserMapper userMapper = context.getBean(\"userMapper\", UserMapper.class);\n        for (User user : userMapper.selectUser()) {\n            System.out.println(user);\n        }\n    }\n}\n```\n\nspring-dao\n\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<beans xmlns=\"http://www.springframework.org/schema/beans\"\n       xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n       xmlns:aop=\"http://www.springframework.org/schema/aop\"\n       xsi:schemaLocation=\"http://www.springframework.org/schema/beans\n        https://www.springframework.org/schema/beans/spring-beans.xsd\n         http://www.springframework.org/schema/aop\n        https://www.springframework.org/schema/aop/spring-aop.xsd\">\n\n  <!--dataSource-->\n    <bean id=\"dataSource\" class=\"org.springframework.jdbc.datasource.DriverManagerDataSource\">\n        <property name=\"driverClassName\" value=\"com.mysql.jdbc.Driver\"/>\n        <property name=\"url\" value=\"jdbc:mysql://localhost:3306/mybatis?serverTimezone=GMT%2B8&amp;useSSL=false\"/>\n        <property name=\"username\" value=\"root\"/>\n        <property name=\"password\" value=\"985211\"/>\n    </bean>\n    <!--SqlSessionFactory-->\n    <bean id=\"sqlSessionFactory\" class=\"org.mybatis.spring.SqlSessionFactoryBean\">\n        <property name=\"dataSource\" ref=\"dataSource\" />\n\n        <property name=\"configLocation\" value=\"classpath:mybatis-config.xml\"/>\n        <property name=\"mapperLocations\" value=\"classpath:com/Gosion/Mapper/UserMapper.xml\"/>\n    </bean>\n    <bean id=\"SqlSession\" class=\"org.mybatis.spring.SqlSessionTemplate\">\n        <constructor-arg index=\"0\" ref=\"sqlSessionFactory\"/>\n    </bean>\n\n    <bean id=\"userMapper\" class=\"com.Gosion.Mapper.UserMapperImpl\">\n        <property name=\"sqlSession\" ref=\"SqlSession\"/>\n    </bean>\n\n</beans>\n```\n\n==整合需要的jar包==\n\n```xml\n<dependencies>\n    <dependency>\n        <groupId>mysql</groupId>\n        <artifactId>mysql-connector-java</artifactId>\n        <version>8.0.11</version>\n    </dependency>\n\n    <dependency>\n        <groupId>org.mybatis</groupId>\n        <artifactId>mybatis</artifactId>\n        <version>3.5.2</version>\n    </dependency>\n\n    <dependency>\n        <groupId>junit</groupId>\n        <artifactId>junit</artifactId>\n        <version>4.12</version>\n    </dependency>\n\n    <dependency>\n        <groupId>org.mybatis</groupId>\n        <artifactId>mybatis-spring</artifactId>\n        <version>2.0.3</version>\n    </dependency>\n\n    <dependency>\n        <groupId>org.springframework</groupId>\n        <artifactId>spring-webmvc</artifactId>\n        <version>5.2.2.RELEASE</version>\n    </dependency>\n\n    <dependency>\n        <groupId>org.springframework</groupId>\n        <artifactId>spring-jdbc</artifactId>\n        <version>5.2.2.RELEASE</version>\n    </dependency>\n    <dependency>\n        <groupId>org.aspectj</groupId>\n        <artifactId>aspectjweaver</artifactId>\n        <version>1.9.4</version>\n    </dependency>\n    <dependency>\n        <groupId>org.projectlombok</groupId>\n        <artifactId>lombok</artifactId>\n        <version>1.18.10</version>\n        <scope>provided</scope>\n    </dependency>\n    <dependency>\n        <groupId>org.springframework</groupId>\n        <artifactId>spring-context</artifactId>\n        <version>5.2.2.RELEASE</version>\n        <scope>test</scope>\n    </dependency>\n</dependencies>\n```\n\n\n\n# 13、声明式事务\n\n\n\n## 1、回顾事务\n\n- 把一组业务当成一个业务来做；要么都成功，要么都失败！\n- 事务在项目开发中十分重要，涉及到数据的一致性问题，不能马虎！\n- 确保完整性，和一致性；\n\n\n\n事务的ACID原则:\n\n- 原子性\n- 一致性\n- 隔离性\n  - 多个业务可能操作同一个资源，防止数据损坏\n- 持久性\n  - 事务一旦提交，无论系统出什么问题，结果都不会再被影响，被持久化的写到存储器中!\n\n## 2、Spring中的事务管理\n\n- 声明式事务：AOP\n- 编程式事务：需要在代码中，进行事务的管理\n\n思考:\n\n为什么需要事务?\n\n- 如果不配置事务，可能存在数据提交不一致的情况下；\n- 如果我们不在Sping中去声明事务，我门就需要在代码中手动配置事务！\n- 事务在项目的开发中十分重要，设计到一致性和完整性问题，不容马虎\n\n\n\n\n\n\n\n\n\n', NULL, 0, 0, 0, NULL, '2020-12-23', 320, NULL, 101);
INSERT INTO `tb_article` VALUES (24, 21, 'mvc', '', '1 Spring     1 1简介  - Spring 春天---------- 给原件行业带来春天 - 2002 首次推出了Spring框架雏形 interface21框架 - 2004年3月24号Spring发布了1 0正式版 - Rod Johnson   Spring Framework创始人  著名作者  很难想象Rod Johnson的学历 真的让好多人大吃一惊 他是 悉尼大学  https   baike baidu com item 悉尼大学 的博士 然而他的专业不是计算机 而是音乐学   - Spring理念 使现有的技术更加容易使用 本身是一个大杂烩 整合了现有的技术框架', '', '\n\n\n\n# 1、Spring\n\n## 1.1简介\n\n- Spring：春天---------->给原件行业带来春天\n- 2002,首次推出了Spring框架雏形:interface21框架\n- 2004年3月24号Spring发布了1.0正式版\n- Rod Johnson ， Spring Framework创始人 ，著名作者。 很难想象Rod Johnson的学历，真的让好多人大吃一惊，他是[悉尼大学](https://baike.baidu.com/item/悉尼大学)的博士，然而他的专业不是计算机，而是音乐学。 \n- Spring理念：使现有的技术更加容易使用，本身是一个大杂烩，整合了现有的技术框架！\n\n\n\n- SSH :	Struct2+Spring+Hibernate!\n- SSM：  SpringMVC+Spring+Mybatis!\n\n- 官网: https://spring.io/projects/spring-framework \n- 官方下载地址: [http://repo.spring.io/release/org/springframework/spring](https://repo.spring.io/release/org/springframework/spring)  \n- GitHub: https://github.com/spring-projects/spring-framework \n\n```xml\n<!-- https://mvnrepository.com/artifact/org.springframework/spring-webmvc -->\n<dependency>\n    <groupId>org.springframework</groupId>\n    <artifactId>spring-webmvc</artifactId>\n    <version>5.2.0.RELEASE</version>\n</dependency>\n<!-- https://mvnrepository.com/artifact/org.springframework/spring-webmvc -->\n<dependency>\n    <groupId>org.springframework</groupId>\n    <artifactId>spring-jdbc</artifactId>\n    <version>5.2.0.RELEASE</version>\n</dependency>\n```\n\n\n\n## 1.2、优点\n\n- Spring是一个开源的免费的框架(容器)！\n- Spring是一个轻量级的、非入侵 式的框架！\n- 控制反转(IOC)，面向切面编程(AOP)！\n- 支持事务的处理，对框架整合的支持！\n\n==总结一句话:Spring就是一个轻量级的控制反转(IOC)和面向切面编程（AOP）的框架！==\n\n\n\n## 1.3组成\n\n![1576133682226](C:\\Users\\guosz\\AppData\\Roaming\\Typora\\typora-user-images\\1576133682226.png)\n\n\n\n## 1.4拓展\n\n在Spring的官网有这个介绍:现代化的java开发!说白就是基于Spring的开发\n\n![1576133880492](C:\\Users\\guosz\\AppData\\Roaming\\Typora\\typora-user-images\\1576133880492.png)\n\n\n\n- Spring Boot\n  - 快速开发的脚手架。\n  - 基于Spring Boot可以快速的开发单个微服务。\n  - 约定大于配置！\n- Spring Cloud\n  - Spring Cloud是基于Spring Boot实现的\n\n因为现在大多数公司都在使用Spring Boot进行快速开发，学习Spring Boot的前提，需要完全掌握Spring及Spring MVC!承上启下的作用!\n\n\n\n**弊端:发展了太久之后,违背了原来的理念!配置十分繁琐，人称配置地狱**\n\n\n\n# 2、IOC理论推导\n\n1.UserDao接口\n\n2.UserDaoImpl实现类\n\n3.UserService业务接口\n\n4.UserServiceImpl 业务实现类\n\n\n\n在我们之前的业务中，用户的需求可能会影响我们原来的代码，我们需要根据用户的需求去修改原代码！如果程序代码量十分大，修改一次的成本代价十分昂贵！\n\n![1576217867883](C:\\Users\\guosz\\AppData\\Roaming\\Typora\\typora-user-images\\1576217867883.png)\n\n我们使用一个Set接口实现. 已经发生了革命性的变化\n\n```java\n private UserDao userDao;\n    //利用set进行动态实现值的注入\n    public  void setUserDao(UserDao userDao) {\n        this.userDao = userDao;\n    }\n```\n\n- 之前，程序是主动创建对象！控制权在程序员手上！\n- 使用set注入后，程序不在具有主动性，而是变成了被动的接受对象!\n\n这种思想，从本质上解决了问题，我们程序员不用再去管理对象的创建了。系统的耦合性大大将达~，可以更加专注的在业务的实现！这是IOC的原型\n\n\n\n![1576217839709](C:\\Users\\guosz\\AppData\\Roaming\\Typora\\typora-user-images\\1576217839709.png)\n\n\n\n\n\n##  IOC本质\n\n控制反转IoC(Inversion of Control)，是一种设计思想，DI(依赖注入)是实现IoC的一种方法**，也有人认为DI只是IoC的另一种说法。没有IoC的程序中 , 我们使用面向对象编程 , 对象的创建与对象间的依赖关系完全硬编码在程序中，对象的创建由程序自己控制，控制反转后将对象的创建转移给第三方，个人认为所谓控制反转就是：获得依赖对象的方式反转了。 \n\n\n\n 采用XML方式配置Bean的时候，Bean的定义信息是和实现分离的，而采用注解的方式可以把两者合为一体，Bean的定义信息直接以注解的形式定义在实现类中，从而达到了零配置的目的。 \n\n **控制反转是一种通过描述（XML或注解）并通过第三方去生产或获取特定对象的方式。在Spring中实现控制反转的是IoC容器，其实现方法是依赖注入（Dependency Injection,DI）。** \n\n\n\n# 3、HelloSpring\n\n## 1.导入Spring相关的jar包\n\n注 : spring 需要导入commons-logging进行日志记录 . 我们利用maven , 他会自动下载对应的依赖项 .\n\n```xml\n<dependency>\n    <groupId>org.springframework</groupId>\n    <artifactId>spring-webmvc</artifactId>\n    <version>5.1.10.RELEASE</version>\n</dependency>\n```\n\n \n\n## 2.编写相关代码\n\n```java\n public class Hello {\n     private String name;\n \n     public String getName() {\n         return name;\n     }\n     public void setName(String name) {\n         this.name = name;\n     }\n \n     public void show(){\n         System.out.println(\"Hello\"+ name );\n     }\n }\n```\n\n \n\n2.2 写编写我们的spring文件 , 这里我们命名为beans.xml\n\n```xml\n   <?xml version=\"1.0\" encoding=\"UTF-8\"?>\n   <beans xmlns=\"http://www.springframework.org/schema/beans\"\n          xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n          xsi:schemaLocation=\"http://www.springframework.org/schema/beans\n           http://www.springframework.org/schema/beans/spring-beans.xsd\">\n   \n       <!--bean就是java对象 , 由Spring创建和管理-->\n       <bean id=\"hello\" class=\"com.kuang.pojo.Hello\">\n          <property name=\"name\" value=\"Spring\"/>\n      </bean>\n  \n  </beans>\n```\n\n \n\n2.3 我们可以去进行测试了 \n\n```java\n @Test\n public void test(){\n     //解析beans.xml文件 , 生成管理相应的Bean对象\n     ApplicationContext context = newClassPathXmlApplicationContext(\"beans.xml\");\n     //getBean : 参数即为spring配置文件中bean的id .\n     Hello hello = (Hello) context.getBean(\"hello\");\n     hello.show();\n }\n```\n\n \n\n### 思考问题 ?\n\n- Hello 对象是谁创建的 ?\n\n  hello 对象是由Spring创建的\n\n- Hello 对象的属性是怎么设置的 ?\n\n  hello 对象的属性是由Spring容器设置的 ,\n\n这个过程就叫控制反转 :\n\n控制 : 谁来控制对象的创建 , 传统应用程序的对象是由程序本身控制创建的 , 使用Spring后 , 对象是由Spring来创建的 .\n\n反转 : 程序本身不创建对象 , 而变成被动的接收对象 .\n\n依赖注入 : 就是利用set方法来进行注入的.\n\nIOC是一种编程思想 , 由主动的编程变成被动的接收 .\n\n可以通过newClassPathXmlApplicationContext去浏览一下底层源码 .\n\n**OK , 到了现在 , 我们彻底不用再程序中去改动了 , 要实现不同的操作 , 只需要在xml配置文件中进行修改 , 所谓的IoC,一句话搞定 : 对象由Spring 来创建 , 管理 , 装配 !**\n\n\n\n# 4.IOC创建对象的方式\n\n1.使用无惨构造创建对象，默认！\n\n2.假设我了吧要使用有参构造创建对象\n\n## 	1.下标赋值\n\n```xml\n<!--第一种下标赋值-->\n<bean id=\"user\" class=\"com.Gosion.pojo.User\">    \n    <constructor-arg index=\"0\" value=\"Gosion学java\"/>\n</bean>\n```\n\n## 	2.类型\n\n```xml\n<!--第二种方式:通过类型创建,不建议使用-->\n    <bean id=\"user\" class=\"com.Gosion.pojo.User\">\n        <constructor-arg type=\"java.lang.String\" value=\"国顺\"/>\n    </bean>\n```\n\n## 	3.通过参数名赋值\n\n```xml\n  <!--第三种 : 直接通过参数名来设置-->\n    <bean id=\"user\" class=\"com.Gosion.pojo.User\">\n        <constructor-arg name=\"name\" value=\"Guoshun\"/>\n    </bean>\n```\n\n\n\n总结:在配置文件中加载的时候，容器中管理的对象就已经初始化了！\n\n\n\n# 5、Spring配置\n\n## 5.1、别名\n\n```xml\n<!--别名,如果添加了别名，我们也可以使用别名来获取这个对象-->\n    <alias name=\"user\" alias=\"usernew\"/>\n```\n\n\n\n## 5.2、Bean的配置\n\n```xml\n    <!--\n    id:bean的唯一标识符，也就是相当于我们学的对象名\n    class:bean  对象所对应的全限定名:包名+类名\n    name: 也是别名,而且name可以同时取多个别名\n    -->\n    <bean id=\"userT\" class=\"com.Gosion.pojo.UserT\" name=\"userT2\">\n\n    </bean>\n```\n\n\n\n\n\n## 5.3 、import\n\n这个import，一般用于团队开发使用，他可以将多个配置文件\n\n假设，现在项目中有多个人开发，这三个人负责不同的类开发，不同的类需要注册在不同的bean中，我们可以利用import将所有人的beans.xml合并为总的！\n\n- 张三\n- 李四\n- 王五\n- applicationContext.xml\n\n```.xml\n <import resource=\"beans.xml\"/>\n    <import resource=\"beans2.xml\"/>\n```\n\n\n\n使用的时候，直接使用中的配置就可以了\n\n\n\n# 6、依赖注入\n\n\n\n## 6.1、构造器注入\n\n前面已经说过了\n\n\n\n## 6.2、Set方式注入【重点】\n\n- 依赖注入:set注入！\n  - 依赖：bean对象的创建依赖于容器\n  - 注入:   bean对象中的所有属性，由容器来注入\n\n\n\n【环境搭建】\n\n​	1.复杂类型\n\n```java\npublic class Address {\n    private String address;\n\n    public String getAddress() {\n        return address;\n    }\n\n    public void setAddress(String address) {\n        this.address = address;\n    }\n}\n```\n\n\n\n​	2.真实测试对象\n\n```java\npublic class Student {\n    private String name;\n    private Address address;\n    private String[] books;\n    private List<String> hobbys;\n    private Map<String,String> card;\n    private Set<String> games;\n    private String wife;\n    private Properties info;\n```\n\n\n\n3.beans.xml\n\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<beans xmlns=\"http://www.springframework.org/schema/beans\"\n       xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n       xsi:schemaLocation=\"http://www.springframework.org/schema/beans\n        https://www.springframework.org/schema/beans/spring-beans.xsd\">\n    <bean id=\"student\" class=\"com.guoshun.pojo.Student\">\n        <!--第一种:普通值注入,value-->\n        <property name=\"name\" value=\"国顺\"/>\n    </bean>\n</beans>\n```\n\n\n\n4.测试类\n\n```java\npublic class MyTest {\n    public static void main(String[] args) {\n        ApplicationContext Context = new ClassPathXmlApplicationContext(\"beans.xml\");\n        Student student = (Student) Context.getBean(\"student\");\n        System.out.printf( student.getName());\n    }\n}\n\n```\n\n\n\n完善注入信息\n\n```xml\n    <bean id=\"address\" class=\"com.guoshun.pojo.Address\">\n        <property name=\"address\" value=\"长沙\"/>\n    </bean>\n    <bean id=\"student\" class=\"com.guoshun.pojo.Student\">\n        <!--第一种:普通值注入,value-->\n        <property name=\"name\" value=\"国顺\"/>\n        <!--第二种bean注入  ref-->\n        <property name=\"address\" ref=\"address\">\n        </property>\n        <!--数组注入-->\n        <property name=\"books\">\n            <array>\n                <value>红楼梦</value>\n                <value>水浒传</value>\n                <value>三国演义</value>\n                <value>西游记</value>\n            </array>\n        </property>\n        <property name=\"hobbys\">\n            <list>\n                <value>听歌</value>\n            </list>\n        </property>\n        <property name=\"card\">\n            <map>\n                <entry key=\"身份证\" value=\"1125457788\"/>\n                <entry key=\"电话\" value=\"191646551\"/>\n            </map>\n        </property>\n        <property name=\"games\">\n            <set>\n                <value>LOL</value>\n                <value>COC</value>\n                <value>BOB</value>\n            </set>\n        </property>\n        <property name=\"wife\">\n            <null/>\n        </property>\n        <property name=\"info\">\n            <props>\n                <prop key=\"driver\">mysql</prop>\n                <prop key=\"url\">root</prop>\n                <prop key=\"password\">985211</prop>\n            </props>\n        </property>\n    </bean>\n```\n\n\n\n## 6.3、拓展方式注入\n\n我们可以使用P命名空间和c命名空间进行注入\n\n官方解释:\n\n使用!\n\n![1576302934268](C:\\Users\\guosz\\AppData\\Roaming\\Typora\\typora-user-images\\1576302934268.png)\n\n测试:\n\n```java\n   @Test\n    public void test2(){\n        ApplicationContext context = new ClassPathXmlApplicationContext(\"userbeans.xml\");\n        User user = (User) context.getBean(\"user\",User.class);\n        System.out.printf( user.toString());\n    }\n```\n\n\n\n注意点:	命名和c命名空间不能直接使用，需要导入XML约束！\n\n```xml\n xmlns:c=\"http://www.springframework.org/schema/c\"\n xmlns:p=\"http://www.springframework.org/schema/p\"\n```\n\n\n\n## 6.4、Bean的作用域\n\n![1576303696640](C:\\Users\\guosz\\AppData\\Roaming\\Typora\\typora-user-images\\1576303696640.png)\n\n\n\n1.单列模式:(Spring默认机制)\n\n```\n<bean id=\"user\" class=\"com.guoshun.pojo.User\" p:name=\"顺哥\" p:age=\"18\" scope=\"singleton\"/>\n```\n\n2.原型模式:每次从容器中get的时候都会产生一个新的对象\n\n```xml\n<bean id=\"accountService\" class=\"com.something.DefaultAccountService\" scope=\"prototype\"/>\n```\n\n3.其余的:request 、Session 、application  这些个只能在Web开发的\n\n\n\n# 7、Bean的自动装配\n\n- 自动装配是Spring满足bean依赖一种方式\n- Spring会在上下文中自动寻找bean，自动给bean装配属性！\n\n在Spring中有三种装配的方式\n\n​	1.在XML中显示的配置\n\n​	2.在java中显示配置\n\n​	3.隐式的自动装配bean【重要!】\n\n\n\n## 7.1、测试\n\n环境搭建:一个人有两个宠物!\n\n\n\n## 7.2、ByName自动装配\n\n```xml\n <!--\n        byName:会自动在容器上下文中查找，和自己对象set方法后面的值对应的bean id！\n        -->\n        <bean id=\"people\" class=\"com.Gosion.pojo.People\" autowire=\"byName\">\n            <property name=\"name\" value=\"靓仔顺\"/>\n        </bean>\n```\n\n\n\n## 7.3、ByType自动装配\n\n```xml\n  <bean id=\"dog\" class=\"com.Gosion.pojo.Dog\"/>\n        <bean id=\"cacdscmdst\" class=\"com.Gosion.pojo.Cat\"/>\n        <!--\n        byName:会自动在容器上下文中查找，和自己对象set方法后面的值对应的bean id！\n        byType:会自动在容器上下文中查找，和自己对象属性类型相同的bean id!\n        -->\n        <bean id=\"people\" class=\"com.Gosion.pojo.People\" autowire=\"byType\">\n            <property name=\"name\" value=\"靓仔顺\"/>\n        </bean>\n```\n\n\n\n小结：\n\n- byname的时候，需要保证所有bean的id唯一，并且这个bean需要和自动注入的属性的set方法发值一致\n- byType的时候，需要保证bean的class唯一，并且这个bean需要和自动注入的属性的类型一致！\n\n\n\n## 7.4、使用注解实现自动装配\n\njdk1.5支持注解,Spring2.5支持注解了！\n\n The introduction of annotation-based configuration raised the question of whether this approach is “better” than XML. \n\n要使用注解须知:\n\n​		1.导入约束。context约束\n\n​		2.配置注解的支持：==<context:annotation-config/>==【重点】\n\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<beans xmlns=\"http://www.springframework.org/schema/beans\"\n    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n    xmlns:context=\"http://www.springframework.org/schema/context\"\n    xsi:schemaLocation=\"http://www.springframework.org/schema/beans\n        https://www.springframework.org/schema/beans/spring-beans.xsd\n        http://www.springframework.org/schema/context\n        https://www.springframework.org/schema/context/spring-context.xsd\">\n\n    <context:annotation-config/>\n\n</beans>\n```\n\n\n\n**@Autowired**\n\n直接在属性上用即可，也可以在Set上使用！\n\n使用@Autowaired我们可以不用编写set方法了，前提是你这个自动装配的属性在IOC(Spring)容器中存在，且符合byname!\n\n科普:\n\n```xml\n@Nullable	字段标记了这个注解,说明这个字段可以为null；\n```\n\n```java\n    //如果显示定义了Autowired的required的属性为false，说明这个对象可以为null否则为空\n    @Autowired(required = false)\n    private Cat cat;\n    @Autowired\n    private Dog dog;\n    private String name;\n```\n\n\n\n如果@Autowired自动装配的环境比较复杂，自动装配无法通过一个注解【@Autowired】完成的时候、我们可以使用@Qualifier(value=\"xxx\")去配合@Autowired的使用，指定一个唯一的对象bean对象注入！\n\n\n\n**@Resouce注解**\n\n需要导入jar包\n\n![1576327301180](C:\\Users\\guosz\\AppData\\Roaming\\Typora\\typora-user-images\\1576327301180.png)\n\n\n\n小结:\n\n@Resouce和@Autowaired区别:\n\n- 都是用来自动装配的，都可以用来放在属性字段上\n- @Autowired通过byname的方式实现，而且必须要求这个对象存在！【常用】\n- @Resource 默认通过byname方式实现，如果找不到名字则通过bytype实现！如果两个都找不到的情况下就报错！【常用】\n- 执行顺序不同:@Autowired byname实现 \n\n\n\n# 8、使用注解开发\n\n在Spring4之后，要使用注解开发，必须要保证aop的包导入了\n\n![1576459409083](C:\\Users\\guosz\\AppData\\Roaming\\Typora\\typora-user-images\\1576459409083.png)\n\n\n\n使用注解需要导入context约束，增加注解支持！\n\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<beans xmlns=\"http://www.springframework.org/schema/beans\"\n    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n    xmlns:context=\"http://www.springframework.org/schema/context\"\n    xsi:schemaLocation=\"http://www.springframework.org/schema/beans\n        https://www.springframework.org/schema/beans/spring-beans.xsd\n        http://www.springframework.org/schema/context\n        https://www.springframework.org/schema/context/spring-context.xsd\">\n\n    <context:annotation-config/>\n\n</beans>\n```\n\n\n\n1.bean\n\n2.属性如何注入\n\n```java\nimport org.springframework.beans.factory.annotation.Value;\nimport org.springframework.stereotype.Component;\n//等价于 <bean id=\"user\" class=\"com.Gosion.pojo.User\">\n//Component 组件\n@Component\npublic class User {\n    //等价于   <property name=\"name\" value=\"gosion\"/>\n    @Value(\"Gosion\")\n    public String name;\n}\n```\n\n3.衍生的注解\n\n@Component有几个衍生注解，在我们web开发中，会按照mvc三层架构分层!\n\n- ​	dao【@Repository】\n\n- service【@Service】\n\n- controller【@Controller】\n\n  这四个注解功能都是一样的，都是代表某个类注册到Spring容器中，装配Bean\n\n4.自动装配\n\n**上面学过了**\n\n5.作用域\n\n```java\nimport org.springframework.beans.factory.annotation.Value;\nimport org.springframework.context.annotation.Scope;\nimport org.springframework.stereotype.Component;\n//等价于 <bean id=\"user\" class=\"com.Gosion.pojo.User\">\n//Component 组件\n@Component\n@Scope(\"prototype\")\npublic class User {\n    //等价于   <property name=\"name\" value=\"gosion\"/>\n    @Value(\"Gosion\")\n    public String name;\n}\n\n```\n\n \n\n6.小结\n\nxml于注解:\n\n- [ ] xml更加万能,使用任何场合,维护简单方便\n- [ ] 注解不是自己的类使用不了，维护相对复杂\n\nxml与注解最佳实践：\n\n- ​	xml用来管理bean\n- 注解只负责完成属性的注入\n- 我们在使用的过程中，只需要注意一个问题：必须让注解生效，就需要开启注解的支持\n\n```xml\n <!--指定要扫描的包，这个包下的注解就会生效-->\n    <context:component-scan base-package=\"com.Gosion\"/>\n    <context:annotation-config/>\n\n```\n\n\n\n# 9、使用java的方式配置Spring\n\n我们现在完全不要使用Spring的xml配置了，全权交给java来做！\n\njavaConfig 是spring的一个子项目,在Spring4之后它变成了核心功能\n\n![1576474773630](C:\\Users\\guosz\\AppData\\Roaming\\Typora\\typora-user-images\\1576474773630.png)\n\n实体类\n\n```java\nimport org.springframework.beans.factory.annotation.Value;\nimport org.springframework.stereotype.Component;\nimport org.springframework.stereotype.Repository;\n//这里这个注解的意思，就是说这个类被Spring接管了，注册到了容器中\n@Component\npublic class User {\n    private String name;\n\n    public String getName() {\n        return name;\n    }\n    @Value(\"guoshun\")//属性注入值\n    public void setName(String name) {\n        this.name = name;\n    }\n}\n\n```\n\n配置类\n\n```java\npackage com.guoshun.config;\n\nimport com.guoshun.pojo.User;\nimport org.springframework.context.annotation.Bean;\nimport org.springframework.context.annotation.ComponentScan;\nimport org.springframework.context.annotation.Configuration;\n\n// Configuration代表这是一个配置类，就和我们之前看的Beans.xml是一样的\n@Configuration//这个也会被Spring容器托管，注册到容器中，因为他本来就是一个@Component，\n@ComponentScan(\"com.guoshun.pojo\")\npublic class GosionConfig {\n    @Bean//注册一个bean，就相当于我们之前写的一个bean标签，\n    //这个方法的名字，就相当与bean标签中的id属性\n    //这个方法的返回值就相当于bean标签的class属性\n    public User getUser(){\n        return new User();//就是返回要返回要注入的对象！\n    }\n}\n\n```\n\n测试类\n\n```java\nimport com.guoshun.config.GosionConfig;\nimport com.guoshun.pojo.User;\nimport org.springframework.context.ApplicationContext;\nimport org.springframework.context.annotation.AnnotationConfigApplicationContext;\n\npublic class MyTest {\n    public static void main(String[] args) {\n        //如果完全使用了配置类方式去做，我们就只能通过AnnotationConfig上下文来获取容器，通过配置类的Class对象加载！\n        ApplicationContext context = new AnnotationConfigApplicationContext(GosionConfig.class);\n        User getUser = (User) context.getBean(\"getUser\");\n        System.out.println(getUser.getName());\n\n\n    }\n}\n```\n\n\n\n这种纯java配置方式，在SpringBoot中随处可见！\n\n\n\n\n\n# 10、代理模式\n\n为什么学代理模式?因为这是Spring AOP的代理层！【SpringAOP和SpringMVC】\n\n代理模式的分类:\n\n- 静态代理\n- 动态代理\n\n![1576477327663](C:\\Users\\guosz\\AppData\\Roaming\\Typora\\typora-user-images\\1576477327663.png)\n\n\n\n## 10.1、代理模式\n\n角色分析:\n\n- 抽象的角色:一般会使用接口或者抽象类来解决\n- 真是角色:被代理的角色\n- 代理角色：代理真是角色，代理真实角色后，我们一般会做一些附属操作\n- 客户:访问代理对象的人\n\n\n\n代码步骤：\n\n​	1.接口\n\n```java\n//租房\npublic interface Rent {\n    public void rent();\n}\n```\n\n​	2.真实角色\n\n```java\n//房东\npublic class Host  implements Rent{\n    @Override\n    public void rent() {\n        System.out.println(\"房东要出租房子\");\n    }\n}\n```\n\n​	3.代理角色\n\n```java\n//代理\npublic class Proxy implements Rent{\n    private Host host;\n\n    public Proxy() {\n    }\n\n    public Proxy(Host host) {\n        this.host = host;\n    }\n\n    @Override\n    public void rent() {\n        seeHouse();\n        host.rent();\n        hetong();\n        fare();\n    }\n    //看房\n    public void seeHouse(){\n        System.out.println(\"中介带你看房\");\n    }\n    //收中介费\n    public  void hetong(){\n        System.out.println(\"签租赁合同\");\n    }\n    //收中介费\n    public  void fare(){\n        System.out.println(\"收中介费\");\n    }\n}\n```\n\n​	4.客户端访问代理角色\n\n```java\npublic class Client {\n    public static void main(String[] args) {\n        //房东要租房子\n        Host host = new Host();\n        //代理 中介帮房东租房子 但是呢 代理角色一般会有一些附属操作\n        Proxy proxy=new Proxy(host);\n        //你不用面对房东，直接找中介租房即可！\n        proxy.rent();\n    }\n}\n```\n\n\n\n\n\n代理模式的好处：\n\n- 可以使真是角色的操作更加纯粹，不用去关注一些公共的业务\n- 公共业务就交给了代理角色,实现了业务的分工！\n- 公共业务发生扩展的时候，方便集中管理！\n\n缺点:\n\n- 一个真实角色就会产生一个代理角色；代码量会翻倍,开发效率会变低\n\n\n\n## 10.2、加深理解\n\n代码对应 08-练习demo2\n\n聊聊AOP\n\n<img src=\"C:\\Users\\guosz\\AppData\\Roaming\\Typora\\typora-user-images\\1576484746469.png\" alt=\"1576484746469\" style=\"zoom: 67%;\" />\n\n\n\n## 10.3、动态代理\n\n- 动态代理，和静态代理角色一样\n- 动态代理的类是动态生成的，不是我们直接写好的\n- 动态代理分为两大类：基于接口的动态代理,基于类的动\n  - 基于接口----JDK动态代理【我们在这了使用】\n  - 基于类：cglib\n  - java字节码实现：javasist\n\n需要了解两个类：Proxy:代理 ,InvocationHandler：调用处理程序\n\n\n\n动态代理的好处:\n\n- 可以使真是角色的操作更加纯粹，不用去关注一些公共的业务\n- 公共业务就交给了代理角色,实现了业务的分工！\n- 公共业务发生扩展的时候，方便集中管理！\n- 一个动态代理类代理的是一个接口，一般就是对应的一类业务\n- 一个动态代理类可以代理多个类，只要实现了同一个接口即可\n\n\n\n# 11、AOP\n\n## 11.1、什么是AOP?\n\n ，AOP为Aspect Oriented Programming的缩写，意为：[面向切面编程](https://baike.baidu.com/item/面向切面编程/6016335)，通过[预编译](https://baike.baidu.com/item/预编译/3191547)方式和运行期动态代理实现程序功能的统一维护的一种技术。AOP是[OOP](https://baike.baidu.com/item/OOP)的延续，是软件开发中的一个热点，也是[Spring](https://baike.baidu.com/item/Spring)框架中的一个重要内容，是[函数式编程](https://baike.baidu.com/item/函数式编程/4035031)的一种衍生范型。利用AOP可以对业务逻辑的各个部分进行隔离，从而使得业务逻辑各部分之间的[耦合度](https://baike.baidu.com/item/耦合度/2603938)降低，提高程序的可重用性，同时提高了开发的效率。 \n\n\n\n\n\n## 11.2、AOP在Spring中的作用\n\n==提供声明事务；允许用户自定义切面==\n\n- 横切关注点：跨越应用程序多个模块的方法或功能，即使，与我们业务逻辑无关的，但我们需要关注分部分，就是横切关注点。如日志，安全，缓存，事务等等\n- 切面:（ASPECT）：切面关注点被模块化的特殊对象。即它是一个类。\n- 通知:(Advice)切面必须要完成的工作\n- 目标(Target):被通知对象\n- 代理（Proxy）:向目标对象应用通知之后创建的对象\n- 切入点(PointCut):切面通知执行的“地点”的定义\n- 连接点（JointPoint）：与切入点匹配的执行点\n\n![1576545392198](C:\\Users\\guosz\\AppData\\Roaming\\Typora\\typora-user-images\\1576545392198.png)\n\nSpringAOP中，通过Advice定义横切逻辑，Spring中支持5种类型的Advice：\n\n<img src=\"C:\\Users\\guosz\\AppData\\Roaming\\Typora\\typora-user-images\\1576568456067.png\" alt=\"1576568456067\" style=\"zoom:67%;\" />\n\n即Aop在不改变原代码的情况下，去增加新的功能\n\n\n\n## 11.3、使用Spring实现AOP\n\n【重点】使用AOP织入，需要导入一个依赖包！\n\n```xml\n<dependency>\n            <groupId>org.aspectj</groupId>\n            <artifactId>aspectjweaver</artifactId>\n            <version>1.9.4</version>\n</dependency>\n```\n\n\n\n\n\n方式一：使用Spring的APl接口 【主要SpringAPI接口实现】\n\n方式二：自定义来实现AOP 【主要是切面定义】\n\n方式三:使用注解实现\n\n\n\n# 12、整合Mybatis\n\n步骤:\n\n1.导入相关jar包\n\n- ​	junit		\n\n- myvatis\n- mysql数据库的\n- spring相关的\n- aop织入\n- mybatis-spring【new 】\n\n2.编写配置文件\n\n3.测试\n\n\n\n## 12.1、回忆mybatis\n\n1. 编写实体类\n\n   \n\n2. 编写核心配置文件\n\n3. 编写接口\n\n4. 编写Mapper.xml\n\n5. 测试\n\n\n\n## 12.2、mybatis-spring\n\n\n\n1. 编写数据源配置\n\n   ```xml\n       <!--DataSource :使用Spring的数据源替换mybatis的配置\n       我们这里使用Spring提供的JDBC\n       -->\n       <bean id=\"dataSource\" class=\"org.springframework.jdbc.datasource.DriverManagerDataSource\">\n           <property name=\"driverClassName\" value=\"com.mysql.jdbc.Driver\"/>\n           <property name=\"url\" value=\"jdbc:mysql:///mybatis\"/>\n           <property name=\"username\" value=\"root\"/>\n           <property name=\"password\" value=\"985211\"/>\n       </bean>\n   ```\n\n2. SqlSessionFactory\n\n   ```xml\n      <!--SqlSessionFactory-->\n       <bean id=\"sqlSessionFactory\" class=\"org.mybatis.spring.SqlSessionFactoryBean\">\n           <property name=\"dataSource\" ref=\"dataSource\" />\n           <!--绑定Mybatis配置文件-->\n           <property name=\"configLocation\" value=\"classpath:mybatis-config.xml\"/>\n           <property name=\"mapperLocations\" value=\"classpath:com/Gosion/Mapper/UserMapper.xml\"/>\n       </bean>\n   ```\n\n3. SqlSessionTemplate\n\n   ```xml\n       <!--SqlSessionTemplate 就是我们使用的SqlSession-->\n       <bean id=\"SqlSession\" class=\"org.mybatis.spring.SqlSessionTemplate\">\n           <!--只能使用构造器注入，因为他没有set方法-->\n               <constructor-arg index=\"0\" ref=\"sqlSessionFactory\"/>\n       </bean>\n   ```\n\n4. 需要给接口加实现类\n\n   ```java\n   import com.Gosion.pojo.User;\n   import org.mybatis.spring.SqlSessionTemplate;\n   \n   import java.util.List;\n   \n   public class USerMapperImpl  implements UserMapper{\n       private SqlSessionTemplate sqlSession;\n   \n       public void setSqlSession(SqlSessionTemplate sqlSession) {\n           this.sqlSession = sqlSession;\n       }\n   \n       //我们的所有操作，都使用sqlSession来执行，在原来，现在都是使用SqlSessionTemplate\n       public List<User> selectUser() {\n   \n           UserMapper mapper = sqlSession.getMapper(UserMapper.class);\n           return mapper.selectUser();\n       }\n   }\n   \n   ```\n\n5. 将自己写的实现类，注入到spring中\n\n   ```xml\n      <!---->\n       <bean id=\"userMapper\" class=\"com.Gosion.Mapper.USerMapperImpl\">\n           <property name=\"sqlSession\" ref=\"SqlSession\"/>\n       </bean>\n   ```\n\n6. 测试即可\n\n```java\nimport com.Gosion.Mapper.UserMapper;\nimport com.Gosion.pojo.User;\nimport org.junit.Test;\nimport org.springframework.context.ApplicationContext;\nimport org.springframework.context.support.ClassPathXmlApplicationContext;\n\nimport java.io.IOException;\n\npublic class MyTest {\n    @Test\n    public void test() throws IOException {\n       ApplicationContext context = new ClassPathXmlApplicationContext(\"applicationContext.xml\");\n        UserMapper userMapper = context.getBean(\"userMapper\", UserMapper.class);\n        for (User user : userMapper.selectUser()) {\n            System.out.println(user);\n        }\n    }\n}\n```\n\nspring-dao\n\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<beans xmlns=\"http://www.springframework.org/schema/beans\"\n       xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n       xmlns:aop=\"http://www.springframework.org/schema/aop\"\n       xsi:schemaLocation=\"http://www.springframework.org/schema/beans\n        https://www.springframework.org/schema/beans/spring-beans.xsd\n         http://www.springframework.org/schema/aop\n        https://www.springframework.org/schema/aop/spring-aop.xsd\">\n\n  <!--dataSource-->\n    <bean id=\"dataSource\" class=\"org.springframework.jdbc.datasource.DriverManagerDataSource\">\n        <property name=\"driverClassName\" value=\"com.mysql.jdbc.Driver\"/>\n        <property name=\"url\" value=\"jdbc:mysql://localhost:3306/mybatis?serverTimezone=GMT%2B8&amp;useSSL=false\"/>\n        <property name=\"username\" value=\"root\"/>\n        <property name=\"password\" value=\"985211\"/>\n    </bean>\n    <!--SqlSessionFactory-->\n    <bean id=\"sqlSessionFactory\" class=\"org.mybatis.spring.SqlSessionFactoryBean\">\n        <property name=\"dataSource\" ref=\"dataSource\" />\n\n        <property name=\"configLocation\" value=\"classpath:mybatis-config.xml\"/>\n        <property name=\"mapperLocations\" value=\"classpath:com/Gosion/Mapper/UserMapper.xml\"/>\n    </bean>\n    <bean id=\"SqlSession\" class=\"org.mybatis.spring.SqlSessionTemplate\">\n        <constructor-arg index=\"0\" ref=\"sqlSessionFactory\"/>\n    </bean>\n\n    <bean id=\"userMapper\" class=\"com.Gosion.Mapper.UserMapperImpl\">\n        <property name=\"sqlSession\" ref=\"SqlSession\"/>\n    </bean>\n\n</beans>\n```\n\n==整合需要的jar包==\n\n```xml\n<dependencies>\n    <dependency>\n        <groupId>mysql</groupId>\n        <artifactId>mysql-connector-java</artifactId>\n        <version>8.0.11</version>\n    </dependency>\n\n    <dependency>\n        <groupId>org.mybatis</groupId>\n        <artifactId>mybatis</artifactId>\n        <version>3.5.2</version>\n    </dependency>\n\n    <dependency>\n        <groupId>junit</groupId>\n        <artifactId>junit</artifactId>\n        <version>4.12</version>\n    </dependency>\n\n    <dependency>\n        <groupId>org.mybatis</groupId>\n        <artifactId>mybatis-spring</artifactId>\n        <version>2.0.3</version>\n    </dependency>\n\n    <dependency>\n        <groupId>org.springframework</groupId>\n        <artifactId>spring-webmvc</artifactId>\n        <version>5.2.2.RELEASE</version>\n    </dependency>\n\n    <dependency>\n        <groupId>org.springframework</groupId>\n        <artifactId>spring-jdbc</artifactId>\n        <version>5.2.2.RELEASE</version>\n    </dependency>\n    <dependency>\n        <groupId>org.aspectj</groupId>\n        <artifactId>aspectjweaver</artifactId>\n        <version>1.9.4</version>\n    </dependency>\n    <dependency>\n        <groupId>org.projectlombok</groupId>\n        <artifactId>lombok</artifactId>\n        <version>1.18.10</version>\n        <scope>provided</scope>\n    </dependency>\n    <dependency>\n        <groupId>org.springframework</groupId>\n        <artifactId>spring-context</artifactId>\n        <version>5.2.2.RELEASE</version>\n        <scope>test</scope>\n    </dependency>\n</dependencies>\n```\n\n\n\n# 13、声明式事务\n\n\n\n## 1、回顾事务\n\n- 把一组业务当成一个业务来做；要么都成功，要么都失败！\n- 事务在项目开发中十分重要，涉及到数据的一致性问题，不能马虎！\n- 确保完整性，和一致性；\n\n\n\n事务的ACID原则:\n\n- 原子性\n- 一致性\n- 隔离性\n  - 多个业务可能操作同一个资源，防止数据损坏\n- 持久性\n  - 事务一旦提交，无论系统出什么问题，结果都不会再被影响，被持久化的写到存储器中!\n\n## 2、Spring中的事务管理\n\n- 声明式事务：AOP\n- 编程式事务：需要在代码中，进行事务的管理\n\n思考:\n\n为什么需要事务?\n\n- 如果不配置事务，可能存在数据提交不一致的情况下；\n- 如果我们不在Sping中去声明事务，我门就需要在代码中手动配置事务！\n- 事务在项目的开发中十分重要，设计到一致性和完整性问题，不容马虎\n\n\n\n\n\n\n\n\n\n', NULL, 0, 0, 0, NULL, '2020-12-23', 320, NULL, 101);
INSERT INTO `tb_article` VALUES (25, 21, 'cdscds', '', 'csd      1 Spring     1 1简介  - Spring 春天---------- 给原件行业带来春天 - 2002 首次推出了Spring框架雏形 interface21框架 - 2004年3月24号Spring发布了1 0正式版 - Rod Johnson   Spring Framework创始人  著名作者  很难想象Rod Johnson的学历 真的让好多人大吃一惊 他是 悉尼大学  https   baike baidu com item 悉尼大学 的博士 然而他的专业不是计算机 而是音乐学   - Spring理念 使现有的技术更加容易使用 本身是一个大杂烩 整', '', 'csd\n\n\n\n# 1、Spring\n\n## 1.1简介\n\n- Spring：春天---------->给原件行业带来春天\n- 2002,首次推出了Spring框架雏形:interface21框架\n- 2004年3月24号Spring发布了1.0正式版\n- Rod Johnson ， Spring Framework创始人 ，著名作者。 很难想象Rod Johnson的学历，真的让好多人大吃一惊，他是[悉尼大学](https://baike.baidu.com/item/悉尼大学)的博士，然而他的专业不是计算机，而是音乐学。 \n- Spring理念：使现有的技术更加容易使用，本身是一个大杂烩，整合了现有的技术框架！\n\n\n\n- SSH :	Struct2+Spring+Hibernate!\n- SSM：  SpringMVC+Spring+Mybatis!\n\n- 官网: https://spring.io/projects/spring-framework \n- 官方下载地址: [http://repo.spring.io/release/org/springframework/spring](https://repo.spring.io/release/org/springframework/spring)  \n- GitHub: https://github.com/spring-projects/spring-framework \n\n```xml\n<!-- https://mvnrepository.com/artifact/org.springframework/spring-webmvc -->\n<dependency>\n    <groupId>org.springframework</groupId>\n    <artifactId>spring-webmvc</artifactId>\n    <version>5.2.0.RELEASE</version>\n</dependency>\n<!-- https://mvnrepository.com/artifact/org.springframework/spring-webmvc -->\n<dependency>\n    <groupId>org.springframework</groupId>\n    <artifactId>spring-jdbc</artifactId>\n    <version>5.2.0.RELEASE</version>\n</dependency>\n```\n\n\n\n## 1.2、优点\n\n- Spring是一个开源的免费的框架(容器)！\n- Spring是一个轻量级的、非入侵 式的框架！\n- 控制反转(IOC)，面向切面编程(AOP)！\n- 支持事务的处理，对框架整合的支持！\n\n==总结一句话:Spring就是一个轻量级的控制反转(IOC)和面向切面编程（AOP）的框架！==\n\n\n\n## 1.3组成\n\n![1576133682226](C:\\Users\\guosz\\AppData\\Roaming\\Typora\\typora-user-images\\1576133682226.png)\n\n\n\n## 1.4拓展\n\n在Spring的官网有这个介绍:现代化的java开发!说白就是基于Spring的开发\n\n![1576133880492](C:\\Users\\guosz\\AppData\\Roaming\\Typora\\typora-user-images\\1576133880492.png)\n\n\n\n- Spring Boot\n  - 快速开发的脚手架。\n  - 基于Spring Boot可以快速的开发单个微服务。\n  - 约定大于配置！\n- Spring Cloud\n  - Spring Cloud是基于Spring Boot实现的\n\n因为现在大多数公司都在使用Spring Boot进行快速开发，学习Spring Boot的前提，需要完全掌握Spring及Spring MVC!承上启下的作用!\n\n\n\n**弊端:发展了太久之后,违背了原来的理念!配置十分繁琐，人称配置地狱**\n\n\n\n# 2、IOC理论推导\n\n1.UserDao接口\n\n2.UserDaoImpl实现类\n\n3.UserService业务接口\n\n4.UserServiceImpl 业务实现类\n\n\n\n在我们之前的业务中，用户的需求可能会影响我们原来的代码，我们需要根据用户的需求去修改原代码！如果程序代码量十分大，修改一次的成本代价十分昂贵！\n\n![1576217867883](C:\\Users\\guosz\\AppData\\Roaming\\Typora\\typora-user-images\\1576217867883.png)\n\n我们使用一个Set接口实现. 已经发生了革命性的变化\n\n```java\n private UserDao userDao;\n    //利用set进行动态实现值的注入\n    public  void setUserDao(UserDao userDao) {\n        this.userDao = userDao;\n    }\n```\n\n- 之前，程序是主动创建对象！控制权在程序员手上！\n- 使用set注入后，程序不在具有主动性，而是变成了被动的接受对象!\n\n这种思想，从本质上解决了问题，我们程序员不用再去管理对象的创建了。系统的耦合性大大将达~，可以更加专注的在业务的实现！这是IOC的原型\n\n\n\n![1576217839709](C:\\Users\\guosz\\AppData\\Roaming\\Typora\\typora-user-images\\1576217839709.png)\n\n\n\n\n\n##  IOC本质\n\n控制反转IoC(Inversion of Control)，是一种设计思想，DI(依赖注入)是实现IoC的一种方法**，也有人认为DI只是IoC的另一种说法。没有IoC的程序中 , 我们使用面向对象编程 , 对象的创建与对象间的依赖关系完全硬编码在程序中，对象的创建由程序自己控制，控制反转后将对象的创建转移给第三方，个人认为所谓控制反转就是：获得依赖对象的方式反转了。 \n\n\n\n 采用XML方式配置Bean的时候，Bean的定义信息是和实现分离的，而采用注解的方式可以把两者合为一体，Bean的定义信息直接以注解的形式定义在实现类中，从而达到了零配置的目的。 \n\n **控制反转是一种通过描述（XML或注解）并通过第三方去生产或获取特定对象的方式。在Spring中实现控制反转的是IoC容器，其实现方法是依赖注入（Dependency Injection,DI）。** \n\n\n\n# 3、HelloSpring\n\n## 1.导入Spring相关的jar包\n\n注 : spring 需要导入commons-logging进行日志记录 . 我们利用maven , 他会自动下载对应的依赖项 .\n\n```xml\n<dependency>\n    <groupId>org.springframework</groupId>\n    <artifactId>spring-webmvc</artifactId>\n    <version>5.1.10.RELEASE</version>\n</dependency>\n```\n\n \n\n## 2.编写相关代码\n\n```java\n public class Hello {\n     private String name;\n \n     public String getName() {\n         return name;\n     }\n     public void setName(String name) {\n         this.name = name;\n     }\n \n     public void show(){\n         System.out.println(\"Hello\"+ name );\n     }\n }\n```\n\n \n\n2.2 写编写我们的spring文件 , 这里我们命名为beans.xml\n\n```xml\n   <?xml version=\"1.0\" encoding=\"UTF-8\"?>\n   <beans xmlns=\"http://www.springframework.org/schema/beans\"\n          xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n          xsi:schemaLocation=\"http://www.springframework.org/schema/beans\n           http://www.springframework.org/schema/beans/spring-beans.xsd\">\n   \n       <!--bean就是java对象 , 由Spring创建和管理-->\n       <bean id=\"hello\" class=\"com.kuang.pojo.Hello\">\n          <property name=\"name\" value=\"Spring\"/>\n      </bean>\n  \n  </beans>\n```\n\n \n\n2.3 我们可以去进行测试了 \n\n```java\n @Test\n public void test(){\n     //解析beans.xml文件 , 生成管理相应的Bean对象\n     ApplicationContext context = newClassPathXmlApplicationContext(\"beans.xml\");\n     //getBean : 参数即为spring配置文件中bean的id .\n     Hello hello = (Hello) context.getBean(\"hello\");\n     hello.show();\n }\n```\n\n \n\n### 思考问题 ?\n\n- Hello 对象是谁创建的 ?\n\n  hello 对象是由Spring创建的\n\n- Hello 对象的属性是怎么设置的 ?\n\n  hello 对象的属性是由Spring容器设置的 ,\n\n这个过程就叫控制反转 :\n\n控制 : 谁来控制对象的创建 , 传统应用程序的对象是由程序本身控制创建的 , 使用Spring后 , 对象是由Spring来创建的 .\n\n反转 : 程序本身不创建对象 , 而变成被动的接收对象 .\n\n依赖注入 : 就是利用set方法来进行注入的.\n\nIOC是一种编程思想 , 由主动的编程变成被动的接收 .\n\n可以通过newClassPathXmlApplicationContext去浏览一下底层源码 .\n\n**OK , 到了现在 , 我们彻底不用再程序中去改动了 , 要实现不同的操作 , 只需要在xml配置文件中进行修改 , 所谓的IoC,一句话搞定 : 对象由Spring 来创建 , 管理 , 装配 !**\n\n\n\n# 4.IOC创建对象的方式\n\n1.使用无惨构造创建对象，默认！\n\n2.假设我了吧要使用有参构造创建对象\n\n## 	1.下标赋值\n\n```xml\n<!--第一种下标赋值-->\n<bean id=\"user\" class=\"com.Gosion.pojo.User\">    \n    <constructor-arg index=\"0\" value=\"Gosion学java\"/>\n</bean>\n```\n\n## 	2.类型\n\n```xml\n<!--第二种方式:通过类型创建,不建议使用-->\n    <bean id=\"user\" class=\"com.Gosion.pojo.User\">\n        <constructor-arg type=\"java.lang.String\" value=\"国顺\"/>\n    </bean>\n```\n\n## 	3.通过参数名赋值\n\n```xml\n  <!--第三种 : 直接通过参数名来设置-->\n    <bean id=\"user\" class=\"com.Gosion.pojo.User\">\n        <constructor-arg name=\"name\" value=\"Guoshun\"/>\n    </bean>\n```\n\n\n\n总结:在配置文件中加载的时候，容器中管理的对象就已经初始化了！\n\n\n\n# 5、Spring配置\n\n## 5.1、别名\n\n```xml\n<!--别名,如果添加了别名，我们也可以使用别名来获取这个对象-->\n    <alias name=\"user\" alias=\"usernew\"/>\n```\n\n\n\n## 5.2、Bean的配置\n\n```xml\n    <!--\n    id:bean的唯一标识符，也就是相当于我们学的对象名\n    class:bean  对象所对应的全限定名:包名+类名\n    name: 也是别名,而且name可以同时取多个别名\n    -->\n    <bean id=\"userT\" class=\"com.Gosion.pojo.UserT\" name=\"userT2\">\n\n    </bean>\n```\n\n\n\n\n\n## 5.3 、import\n\n这个import，一般用于团队开发使用，他可以将多个配置文件\n\n假设，现在项目中有多个人开发，这三个人负责不同的类开发，不同的类需要注册在不同的bean中，我们可以利用import将所有人的beans.xml合并为总的！\n\n- 张三\n- 李四\n- 王五\n- applicationContext.xml\n\n```.xml\n <import resource=\"beans.xml\"/>\n    <import resource=\"beans2.xml\"/>\n```\n\n\n\n使用的时候，直接使用中的配置就可以了\n\n\n\n# 6、依赖注入\n\n\n\n## 6.1、构造器注入\n\n前面已经说过了\n\n\n\n## 6.2、Set方式注入【重点】\n\n- 依赖注入:set注入！\n  - 依赖：bean对象的创建依赖于容器\n  - 注入:   bean对象中的所有属性，由容器来注入\n\n\n\n【环境搭建】\n\n​	1.复杂类型\n\n```java\npublic class Address {\n    private String address;\n\n    public String getAddress() {\n        return address;\n    }\n\n    public void setAddress(String address) {\n        this.address = address;\n    }\n}\n```\n\n\n\n​	2.真实测试对象\n\n```java\npublic class Student {\n    private String name;\n    private Address address;\n    private String[] books;\n    private List<String> hobbys;\n    private Map<String,String> card;\n    private Set<String> games;\n    private String wife;\n    private Properties info;\n```\n\n\n\n3.beans.xml\n\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<beans xmlns=\"http://www.springframework.org/schema/beans\"\n       xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n       xsi:schemaLocation=\"http://www.springframework.org/schema/beans\n        https://www.springframework.org/schema/beans/spring-beans.xsd\">\n    <bean id=\"student\" class=\"com.guoshun.pojo.Student\">\n        <!--第一种:普通值注入,value-->\n        <property name=\"name\" value=\"国顺\"/>\n    </bean>\n</beans>\n```\n\n\n\n4.测试类\n\n```java\npublic class MyTest {\n    public static void main(String[] args) {\n        ApplicationContext Context = new ClassPathXmlApplicationContext(\"beans.xml\");\n        Student student = (Student) Context.getBean(\"student\");\n        System.out.printf( student.getName());\n    }\n}\n\n```\n\n\n\n完善注入信息\n\n```xml\n    <bean id=\"address\" class=\"com.guoshun.pojo.Address\">\n        <property name=\"address\" value=\"长沙\"/>\n    </bean>\n    <bean id=\"student\" class=\"com.guoshun.pojo.Student\">\n        <!--第一种:普通值注入,value-->\n        <property name=\"name\" value=\"国顺\"/>\n        <!--第二种bean注入  ref-->\n        <property name=\"address\" ref=\"address\">\n        </property>\n        <!--数组注入-->\n        <property name=\"books\">\n            <array>\n                <value>红楼梦</value>\n                <value>水浒传</value>\n                <value>三国演义</value>\n                <value>西游记</value>\n            </array>\n        </property>\n        <property name=\"hobbys\">\n            <list>\n                <value>听歌</value>\n            </list>\n        </property>\n        <property name=\"card\">\n            <map>\n                <entry key=\"身份证\" value=\"1125457788\"/>\n                <entry key=\"电话\" value=\"191646551\"/>\n            </map>\n        </property>\n        <property name=\"games\">\n            <set>\n                <value>LOL</value>\n                <value>COC</value>\n                <value>BOB</value>\n            </set>\n        </property>\n        <property name=\"wife\">\n            <null/>\n        </property>\n        <property name=\"info\">\n            <props>\n                <prop key=\"driver\">mysql</prop>\n                <prop key=\"url\">root</prop>\n                <prop key=\"password\">985211</prop>\n            </props>\n        </property>\n    </bean>\n```\n\n\n\n## 6.3、拓展方式注入\n\n我们可以使用P命名空间和c命名空间进行注入\n\n官方解释:\n\n使用!\n\n![1576302934268](C:\\Users\\guosz\\AppData\\Roaming\\Typora\\typora-user-images\\1576302934268.png)\n\n测试:\n\n```java\n   @Test\n    public void test2(){\n        ApplicationContext context = new ClassPathXmlApplicationContext(\"userbeans.xml\");\n        User user = (User) context.getBean(\"user\",User.class);\n        System.out.printf( user.toString());\n    }\n```\n\n\n\n注意点:	命名和c命名空间不能直接使用，需要导入XML约束！\n\n```xml\n xmlns:c=\"http://www.springframework.org/schema/c\"\n xmlns:p=\"http://www.springframework.org/schema/p\"\n```\n\n\n\n## 6.4、Bean的作用域\n\n![1576303696640](C:\\Users\\guosz\\AppData\\Roaming\\Typora\\typora-user-images\\1576303696640.png)\n\n\n\n1.单列模式:(Spring默认机制)\n\n```\n<bean id=\"user\" class=\"com.guoshun.pojo.User\" p:name=\"顺哥\" p:age=\"18\" scope=\"singleton\"/>\n```\n\n2.原型模式:每次从容器中get的时候都会产生一个新的对象\n\n```xml\n<bean id=\"accountService\" class=\"com.something.DefaultAccountService\" scope=\"prototype\"/>\n```\n\n3.其余的:request 、Session 、application  这些个只能在Web开发的\n\n\n\n# 7、Bean的自动装配\n\n- 自动装配是Spring满足bean依赖一种方式\n- Spring会在上下文中自动寻找bean，自动给bean装配属性！\n\n在Spring中有三种装配的方式\n\n​	1.在XML中显示的配置\n\n​	2.在java中显示配置\n\n​	3.隐式的自动装配bean【重要!】\n\n\n\n## 7.1、测试\n\n环境搭建:一个人有两个宠物!\n\n\n\n## 7.2、ByName自动装配\n\n```xml\n <!--\n        byName:会自动在容器上下文中查找，和自己对象set方法后面的值对应的bean id！\n        -->\n        <bean id=\"people\" class=\"com.Gosion.pojo.People\" autowire=\"byName\">\n            <property name=\"name\" value=\"靓仔顺\"/>\n        </bean>\n```\n\n\n\n## 7.3、ByType自动装配\n\n```xml\n  <bean id=\"dog\" class=\"com.Gosion.pojo.Dog\"/>\n        <bean id=\"cacdscmdst\" class=\"com.Gosion.pojo.Cat\"/>\n        <!--\n        byName:会自动在容器上下文中查找，和自己对象set方法后面的值对应的bean id！\n        byType:会自动在容器上下文中查找，和自己对象属性类型相同的bean id!\n        -->\n        <bean id=\"people\" class=\"com.Gosion.pojo.People\" autowire=\"byType\">\n            <property name=\"name\" value=\"靓仔顺\"/>\n        </bean>\n```\n\n\n\n小结：\n\n- byname的时候，需要保证所有bean的id唯一，并且这个bean需要和自动注入的属性的set方法发值一致\n- byType的时候，需要保证bean的class唯一，并且这个bean需要和自动注入的属性的类型一致！\n\n\n\n## 7.4、使用注解实现自动装配\n\njdk1.5支持注解,Spring2.5支持注解了！\n\n The introduction of annotation-based configuration raised the question of whether this approach is “better” than XML. \n\n要使用注解须知:\n\n​		1.导入约束。context约束\n\n​		2.配置注解的支持：==<context:annotation-config/>==【重点】\n\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<beans xmlns=\"http://www.springframework.org/schema/beans\"\n    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n    xmlns:context=\"http://www.springframework.org/schema/context\"\n    xsi:schemaLocation=\"http://www.springframework.org/schema/beans\n        https://www.springframework.org/schema/beans/spring-beans.xsd\n        http://www.springframework.org/schema/context\n        https://www.springframework.org/schema/context/spring-context.xsd\">\n\n    <context:annotation-config/>\n\n</beans>\n```\n\n\n\n**@Autowired**\n\n直接在属性上用即可，也可以在Set上使用！\n\n使用@Autowaired我们可以不用编写set方法了，前提是你这个自动装配的属性在IOC(Spring)容器中存在，且符合byname!\n\n科普:\n\n```xml\n@Nullable	字段标记了这个注解,说明这个字段可以为null；\n```\n\n```java\n    //如果显示定义了Autowired的required的属性为false，说明这个对象可以为null否则为空\n    @Autowired(required = false)\n    private Cat cat;\n    @Autowired\n    private Dog dog;\n    private String name;\n```\n\n\n\n如果@Autowired自动装配的环境比较复杂，自动装配无法通过一个注解【@Autowired】完成的时候、我们可以使用@Qualifier(value=\"xxx\")去配合@Autowired的使用，指定一个唯一的对象bean对象注入！\n\n\n\n**@Resouce注解**\n\n需要导入jar包\n\n![1576327301180](C:\\Users\\guosz\\AppData\\Roaming\\Typora\\typora-user-images\\1576327301180.png)\n\n\n\n小结:\n\n@Resouce和@Autowaired区别:\n\n- 都是用来自动装配的，都可以用来放在属性字段上\n- @Autowired通过byname的方式实现，而且必须要求这个对象存在！【常用】\n- @Resource 默认通过byname方式实现，如果找不到名字则通过bytype实现！如果两个都找不到的情况下就报错！【常用】\n- 执行顺序不同:@Autowired byname实现 \n\n\n\n# 8、使用注解开发\n\n在Spring4之后，要使用注解开发，必须要保证aop的包导入了\n\n![1576459409083](C:\\Users\\guosz\\AppData\\Roaming\\Typora\\typora-user-images\\1576459409083.png)\n\n\n\n使用注解需要导入context约束，增加注解支持！\n\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<beans xmlns=\"http://www.springframework.org/schema/beans\"\n    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n    xmlns:context=\"http://www.springframework.org/schema/context\"\n    xsi:schemaLocation=\"http://www.springframework.org/schema/beans\n        https://www.springframework.org/schema/beans/spring-beans.xsd\n        http://www.springframework.org/schema/context\n        https://www.springframework.org/schema/context/spring-context.xsd\">\n\n    <context:annotation-config/>\n\n</beans>\n```\n\n\n\n1.bean\n\n2.属性如何注入\n\n```java\nimport org.springframework.beans.factory.annotation.Value;\nimport org.springframework.stereotype.Component;\n//等价于 <bean id=\"user\" class=\"com.Gosion.pojo.User\">\n//Component 组件\n@Component\npublic class User {\n    //等价于   <property name=\"name\" value=\"gosion\"/>\n    @Value(\"Gosion\")\n    public String name;\n}\n```\n\n3.衍生的注解\n\n@Component有几个衍生注解，在我们web开发中，会按照mvc三层架构分层!\n\n- ​	dao【@Repository】\n\n- service【@Service】\n\n- controller【@Controller】\n\n  这四个注解功能都是一样的，都是代表某个类注册到Spring容器中，装配Bean\n\n4.自动装配\n\n**上面学过了**\n\n5.作用域\n\n```java\nimport org.springframework.beans.factory.annotation.Value;\nimport org.springframework.context.annotation.Scope;\nimport org.springframework.stereotype.Component;\n//等价于 <bean id=\"user\" class=\"com.Gosion.pojo.User\">\n//Component 组件\n@Component\n@Scope(\"prototype\")\npublic class User {\n    //等价于   <property name=\"name\" value=\"gosion\"/>\n    @Value(\"Gosion\")\n    public String name;\n}\n\n```\n\n \n\n6.小结\n\nxml于注解:\n\n- [ ] xml更加万能,使用任何场合,维护简单方便\n- [ ] 注解不是自己的类使用不了，维护相对复杂\n\nxml与注解最佳实践：\n\n- ​	xml用来管理bean\n- 注解只负责完成属性的注入\n- 我们在使用的过程中，只需要注意一个问题：必须让注解生效，就需要开启注解的支持\n\n```xml\n <!--指定要扫描的包，这个包下的注解就会生效-->\n    <context:component-scan base-package=\"com.Gosion\"/>\n    <context:annotation-config/>\n\n```\n\n\n\n# 9、使用java的方式配置Spring\n\n我们现在完全不要使用Spring的xml配置了，全权交给java来做！\n\njavaConfig 是spring的一个子项目,在Spring4之后它变成了核心功能\n\n![1576474773630](C:\\Users\\guosz\\AppData\\Roaming\\Typora\\typora-user-images\\1576474773630.png)\n\n实体类\n\n```java\nimport org.springframework.beans.factory.annotation.Value;\nimport org.springframework.stereotype.Component;\nimport org.springframework.stereotype.Repository;\n//这里这个注解的意思，就是说这个类被Spring接管了，注册到了容器中\n@Component\npublic class User {\n    private String name;\n\n    public String getName() {\n        return name;\n    }\n    @Value(\"guoshun\")//属性注入值\n    public void setName(String name) {\n        this.name = name;\n    }\n}\n\n```\n\n配置类\n\n```java\npackage com.guoshun.config;\n\nimport com.guoshun.pojo.User;\nimport org.springframework.context.annotation.Bean;\nimport org.springframework.context.annotation.ComponentScan;\nimport org.springframework.context.annotation.Configuration;\n\n// Configuration代表这是一个配置类，就和我们之前看的Beans.xml是一样的\n@Configuration//这个也会被Spring容器托管，注册到容器中，因为他本来就是一个@Component，\n@ComponentScan(\"com.guoshun.pojo\")\npublic class GosionConfig {\n    @Bean//注册一个bean，就相当于我们之前写的一个bean标签，\n    //这个方法的名字，就相当与bean标签中的id属性\n    //这个方法的返回值就相当于bean标签的class属性\n    public User getUser(){\n        return new User();//就是返回要返回要注入的对象！\n    }\n}\n\n```\n\n测试类\n\n```java\nimport com.guoshun.config.GosionConfig;\nimport com.guoshun.pojo.User;\nimport org.springframework.context.ApplicationContext;\nimport org.springframework.context.annotation.AnnotationConfigApplicationContext;\n\npublic class MyTest {\n    public static void main(String[] args) {\n        //如果完全使用了配置类方式去做，我们就只能通过AnnotationConfig上下文来获取容器，通过配置类的Class对象加载！\n        ApplicationContext context = new AnnotationConfigApplicationContext(GosionConfig.class);\n        User getUser = (User) context.getBean(\"getUser\");\n        System.out.println(getUser.getName());\n\n\n    }\n}\n```\n\n\n\n这种纯java配置方式，在SpringBoot中随处可见！\n\n\n\n\n\n# 10、代理模式\n\n为什么学代理模式?因为这是Spring AOP的代理层！【SpringAOP和SpringMVC】\n\n代理模式的分类:\n\n- 静态代理\n- 动态代理\n\n![1576477327663](C:\\Users\\guosz\\AppData\\Roaming\\Typora\\typora-user-images\\1576477327663.png)\n\n\n\n## 10.1、代理模式\n\n角色分析:\n\n- 抽象的角色:一般会使用接口或者抽象类来解决\n- 真是角色:被代理的角色\n- 代理角色：代理真是角色，代理真实角色后，我们一般会做一些附属操作\n- 客户:访问代理对象的人\n\n\n\n代码步骤：\n\n​	1.接口\n\n```java\n//租房\npublic interface Rent {\n    public void rent();\n}\n```\n\n​	2.真实角色\n\n```java\n//房东\npublic class Host  implements Rent{\n    @Override\n    public void rent() {\n        System.out.println(\"房东要出租房子\");\n    }\n}\n```\n\n​	3.代理角色\n\n```java\n//代理\npublic class Proxy implements Rent{\n    private Host host;\n\n    public Proxy() {\n    }\n\n    public Proxy(Host host) {\n        this.host = host;\n    }\n\n    @Override\n    public void rent() {\n        seeHouse();\n        host.rent();\n        hetong();\n        fare();\n    }\n    //看房\n    public void seeHouse(){\n        System.out.println(\"中介带你看房\");\n    }\n    //收中介费\n    public  void hetong(){\n        System.out.println(\"签租赁合同\");\n    }\n    //收中介费\n    public  void fare(){\n        System.out.println(\"收中介费\");\n    }\n}\n```\n\n​	4.客户端访问代理角色\n\n```java\npublic class Client {\n    public static void main(String[] args) {\n        //房东要租房子\n        Host host = new Host();\n        //代理 中介帮房东租房子 但是呢 代理角色一般会有一些附属操作\n        Proxy proxy=new Proxy(host);\n        //你不用面对房东，直接找中介租房即可！\n        proxy.rent();\n    }\n}\n```\n\n\n\n\n\n代理模式的好处：\n\n- 可以使真是角色的操作更加纯粹，不用去关注一些公共的业务\n- 公共业务就交给了代理角色,实现了业务的分工！\n- 公共业务发生扩展的时候，方便集中管理！\n\n缺点:\n\n- 一个真实角色就会产生一个代理角色；代码量会翻倍,开发效率会变低\n\n\n\n## 10.2、加深理解\n\n代码对应 08-练习demo2\n\n聊聊AOP\n\n<img src=\"C:\\Users\\guosz\\AppData\\Roaming\\Typora\\typora-user-images\\1576484746469.png\" alt=\"1576484746469\" style=\"zoom: 67%;\" />\n\n\n\n## 10.3、动态代理\n\n- 动态代理，和静态代理角色一样\n- 动态代理的类是动态生成的，不是我们直接写好的\n- 动态代理分为两大类：基于接口的动态代理,基于类的动\n  - 基于接口----JDK动态代理【我们在这了使用】\n  - 基于类：cglib\n  - java字节码实现：javasist\n\n需要了解两个类：Proxy:代理 ,InvocationHandler：调用处理程序\n\n\n\n动态代理的好处:\n\n- 可以使真是角色的操作更加纯粹，不用去关注一些公共的业务\n- 公共业务就交给了代理角色,实现了业务的分工！\n- 公共业务发生扩展的时候，方便集中管理！\n- 一个动态代理类代理的是一个接口，一般就是对应的一类业务\n- 一个动态代理类可以代理多个类，只要实现了同一个接口即可\n\n\n\n# 11、AOP\n\n## 11.1、什么是AOP?\n\n ，AOP为Aspect Oriented Programming的缩写，意为：[面向切面编程](https://baike.baidu.com/item/面向切面编程/6016335)，通过[预编译](https://baike.baidu.com/item/预编译/3191547)方式和运行期动态代理实现程序功能的统一维护的一种技术。AOP是[OOP](https://baike.baidu.com/item/OOP)的延续，是软件开发中的一个热点，也是[Spring](https://baike.baidu.com/item/Spring)框架中的一个重要内容，是[函数式编程](https://baike.baidu.com/item/函数式编程/4035031)的一种衍生范型。利用AOP可以对业务逻辑的各个部分进行隔离，从而使得业务逻辑各部分之间的[耦合度](https://baike.baidu.com/item/耦合度/2603938)降低，提高程序的可重用性，同时提高了开发的效率。 \n\n\n\n\n\n## 11.2、AOP在Spring中的作用\n\n==提供声明事务；允许用户自定义切面==\n\n- 横切关注点：跨越应用程序多个模块的方法或功能，即使，与我们业务逻辑无关的，但我们需要关注分部分，就是横切关注点。如日志，安全，缓存，事务等等\n- 切面:（ASPECT）：切面关注点被模块化的特殊对象。即它是一个类。\n- 通知:(Advice)切面必须要完成的工作\n- 目标(Target):被通知对象\n- 代理（Proxy）:向目标对象应用通知之后创建的对象\n- 切入点(PointCut):切面通知执行的“地点”的定义\n- 连接点（JointPoint）：与切入点匹配的执行点\n\n![1576545392198](C:\\Users\\guosz\\AppData\\Roaming\\Typora\\typora-user-images\\1576545392198.png)\n\nSpringAOP中，通过Advice定义横切逻辑，Spring中支持5种类型的Advice：\n\n<img src=\"C:\\Users\\guosz\\AppData\\Roaming\\Typora\\typora-user-images\\1576568456067.png\" alt=\"1576568456067\" style=\"zoom:67%;\" />\n\n即Aop在不改变原代码的情况下，去增加新的功能\n\n\n\n## 11.3、使用Spring实现AOP\n\n【重点】使用AOP织入，需要导入一个依赖包！\n\n```xml\n<dependency>\n            <groupId>org.aspectj</groupId>\n            <artifactId>aspectjweaver</artifactId>\n            <version>1.9.4</version>\n</dependency>\n```\n\n\n\n\n\n方式一：使用Spring的APl接口 【主要SpringAPI接口实现】\n\n方式二：自定义来实现AOP 【主要是切面定义】\n\n方式三:使用注解实现\n\n\n\n# 12、整合Mybatis\n\n步骤:\n\n1.导入相关jar包\n\n- ​	junit		\n\n- myvatis\n- mysql数据库的\n- spring相关的\n- aop织入\n- mybatis-spring【new 】\n\n2.编写配置文件\n\n3.测试\n\n\n\n## 12.1、回忆mybatis\n\n1. 编写实体类\n\n   \n\n2. 编写核心配置文件\n\n3. 编写接口\n\n4. 编写Mapper.xml\n\n5. 测试\n\n\n\n## 12.2、mybatis-spring\n\n\n\n1. 编写数据源配置\n\n   ```xml\n       <!--DataSource :使用Spring的数据源替换mybatis的配置\n       我们这里使用Spring提供的JDBC\n       -->\n       <bean id=\"dataSource\" class=\"org.springframework.jdbc.datasource.DriverManagerDataSource\">\n           <property name=\"driverClassName\" value=\"com.mysql.jdbc.Driver\"/>\n           <property name=\"url\" value=\"jdbc:mysql:///mybatis\"/>\n           <property name=\"username\" value=\"root\"/>\n           <property name=\"password\" value=\"985211\"/>\n       </bean>\n   ```\n\n2. SqlSessionFactory\n\n   ```xml\n      <!--SqlSessionFactory-->\n       <bean id=\"sqlSessionFactory\" class=\"org.mybatis.spring.SqlSessionFactoryBean\">\n           <property name=\"dataSource\" ref=\"dataSource\" />\n           <!--绑定Mybatis配置文件-->\n           <property name=\"configLocation\" value=\"classpath:mybatis-config.xml\"/>\n           <property name=\"mapperLocations\" value=\"classpath:com/Gosion/Mapper/UserMapper.xml\"/>\n       </bean>\n   ```\n\n3. SqlSessionTemplate\n\n   ```xml\n       <!--SqlSessionTemplate 就是我们使用的SqlSession-->\n       <bean id=\"SqlSession\" class=\"org.mybatis.spring.SqlSessionTemplate\">\n           <!--只能使用构造器注入，因为他没有set方法-->\n               <constructor-arg index=\"0\" ref=\"sqlSessionFactory\"/>\n       </bean>\n   ```\n\n4. 需要给接口加实现类\n\n   ```java\n   import com.Gosion.pojo.User;\n   import org.mybatis.spring.SqlSessionTemplate;\n   \n   import java.util.List;\n   \n   public class USerMapperImpl  implements UserMapper{\n       private SqlSessionTemplate sqlSession;\n   \n       public void setSqlSession(SqlSessionTemplate sqlSession) {\n           this.sqlSession = sqlSession;\n       }\n   \n       //我们的所有操作，都使用sqlSession来执行，在原来，现在都是使用SqlSessionTemplate\n       public List<User> selectUser() {\n   \n           UserMapper mapper = sqlSession.getMapper(UserMapper.class);\n           return mapper.selectUser();\n       }\n   }\n   \n   ```\n\n5. 将自己写的实现类，注入到spring中\n\n   ```xml\n      <!---->\n       <bean id=\"userMapper\" class=\"com.Gosion.Mapper.USerMapperImpl\">\n           <property name=\"sqlSession\" ref=\"SqlSession\"/>\n       </bean>\n   ```\n\n6. 测试即可\n\n```java\nimport com.Gosion.Mapper.UserMapper;\nimport com.Gosion.pojo.User;\nimport org.junit.Test;\nimport org.springframework.context.ApplicationContext;\nimport org.springframework.context.support.ClassPathXmlApplicationContext;\n\nimport java.io.IOException;\n\npublic class MyTest {\n    @Test\n    public void test() throws IOException {\n       ApplicationContext context = new ClassPathXmlApplicationContext(\"applicationContext.xml\");\n        UserMapper userMapper = context.getBean(\"userMapper\", UserMapper.class);\n        for (User user : userMapper.selectUser()) {\n            System.out.println(user);\n        }\n    }\n}\n```\n\nspring-dao\n\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<beans xmlns=\"http://www.springframework.org/schema/beans\"\n       xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n       xmlns:aop=\"http://www.springframework.org/schema/aop\"\n       xsi:schemaLocation=\"http://www.springframework.org/schema/beans\n        https://www.springframework.org/schema/beans/spring-beans.xsd\n         http://www.springframework.org/schema/aop\n        https://www.springframework.org/schema/aop/spring-aop.xsd\">\n\n  <!--dataSource-->\n    <bean id=\"dataSource\" class=\"org.springframework.jdbc.datasource.DriverManagerDataSource\">\n        <property name=\"driverClassName\" value=\"com.mysql.jdbc.Driver\"/>\n        <property name=\"url\" value=\"jdbc:mysql://localhost:3306/mybatis?serverTimezone=GMT%2B8&amp;useSSL=false\"/>\n        <property name=\"username\" value=\"root\"/>\n        <property name=\"password\" value=\"985211\"/>\n    </bean>\n    <!--SqlSessionFactory-->\n    <bean id=\"sqlSessionFactory\" class=\"org.mybatis.spring.SqlSessionFactoryBean\">\n        <property name=\"dataSource\" ref=\"dataSource\" />\n\n        <property name=\"configLocation\" value=\"classpath:mybatis-config.xml\"/>\n        <property name=\"mapperLocations\" value=\"classpath:com/Gosion/Mapper/UserMapper.xml\"/>\n    </bean>\n    <bean id=\"SqlSession\" class=\"org.mybatis.spring.SqlSessionTemplate\">\n        <constructor-arg index=\"0\" ref=\"sqlSessionFactory\"/>\n    </bean>\n\n    <bean id=\"userMapper\" class=\"com.Gosion.Mapper.UserMapperImpl\">\n        <property name=\"sqlSession\" ref=\"SqlSession\"/>\n    </bean>\n\n</beans>\n```\n\n==整合需要的jar包==\n\n```xml\n<dependencies>\n    <dependency>\n        <groupId>mysql</groupId>\n        <artifactId>mysql-connector-java</artifactId>\n        <version>8.0.11</version>\n    </dependency>\n\n    <dependency>\n        <groupId>org.mybatis</groupId>\n        <artifactId>mybatis</artifactId>\n        <version>3.5.2</version>\n    </dependency>\n\n    <dependency>\n        <groupId>junit</groupId>\n        <artifactId>junit</artifactId>\n        <version>4.12</version>\n    </dependency>\n\n    <dependency>\n        <groupId>org.mybatis</groupId>\n        <artifactId>mybatis-spring</artifactId>\n        <version>2.0.3</version>\n    </dependency>\n\n    <dependency>\n        <groupId>org.springframework</groupId>\n        <artifactId>spring-webmvc</artifactId>\n        <version>5.2.2.RELEASE</version>\n    </dependency>\n\n    <dependency>\n        <groupId>org.springframework</groupId>\n        <artifactId>spring-jdbc</artifactId>\n        <version>5.2.2.RELEASE</version>\n    </dependency>\n    <dependency>\n        <groupId>org.aspectj</groupId>\n        <artifactId>aspectjweaver</artifactId>\n        <version>1.9.4</version>\n    </dependency>\n    <dependency>\n        <groupId>org.projectlombok</groupId>\n        <artifactId>lombok</artifactId>\n        <version>1.18.10</version>\n        <scope>provided</scope>\n    </dependency>\n    <dependency>\n        <groupId>org.springframework</groupId>\n        <artifactId>spring-context</artifactId>\n        <version>5.2.2.RELEASE</version>\n        <scope>test</scope>\n    </dependency>\n</dependencies>\n```\n\n\n\n# 13、声明式事务\n\n\n\n## 1、回顾事务\n\n- 把一组业务当成一个业务来做；要么都成功，要么都失败！\n- 事务在项目开发中十分重要，涉及到数据的一致性问题，不能马虎！\n- 确保完整性，和一致性；\n\n\n\n事务的ACID原则:\n\n- 原子性\n- 一致性\n- 隔离性\n  - 多个业务可能操作同一个资源，防止数据损坏\n- 持久性\n  - 事务一旦提交，无论系统出什么问题，结果都不会再被影响，被持久化的写到存储器中!\n\n## 2、Spring中的事务管理\n\n- 声明式事务：AOP\n- 编程式事务：需要在代码中，进行事务的管理\n\n思考:\n\n为什么需要事务?\n\n- 如果不配置事务，可能存在数据提交不一致的情况下；\n- 如果我们不在Sping中去声明事务，我门就需要在代码中手动配置事务！\n- 事务在项目的开发中十分重要，设计到一致性和完整性问题，不容马虎\n\n\n\n\n\n\n\n\n\n', NULL, 0, 0, 0, NULL, '2020-12-23', 320, NULL, 101);
INSERT INTO `tb_article` VALUES (26, 20, 'nihao', '', '1 Spring     1 1简介  - Spring 春天---------- 给原件行业带来春天 - 2002 首次推出了Spring框架雏形 interface21框架 - 2004年3月24号Spring发布了1 0正式版 - Rod Johnson   Spring Framework创始人  著名作者  很难想象Rod Johnson的学历 真的让好多人大吃一惊 他是 悉尼大学  https   baike baidu com item 悉尼大学 的博士 然而他的专业不是计算机 而是音乐学   - Spring理念 使现有的技术更加容易使用 本身是一个大杂烩 整合了现有的技术框架', '', '\n\n\n\n# 1、Spring\n\n## 1.1简介\n\n- Spring：春天---------->给原件行业带来春天\n- 2002,首次推出了Spring框架雏形:interface21框架\n- 2004年3月24号Spring发布了1.0正式版\n- Rod Johnson ， Spring Framework创始人 ，著名作者。 很难想象Rod Johnson的学历，真的让好多人大吃一惊，他是[悉尼大学](https://baike.baidu.com/item/悉尼大学)的博士，然而他的专业不是计算机，而是音乐学。 \n- Spring理念：使现有的技术更加容易使用，本身是一个大杂烩，整合了现有的技术框架！\n\n\n\n- SSH :	Struct2+Spring+Hibernate!\n- SSM：  SpringMVC+Spring+Mybatis!\n\n- 官网: https://spring.io/projects/spring-framework \n- 官方下载地址: [http://repo.spring.io/release/org/springframework/spring](https://repo.spring.io/release/org/springframework/spring)  \n- GitHub: https://github.com/spring-projects/spring-framework \n\n```xml\n<!-- https://mvnrepository.com/artifact/org.springframework/spring-webmvc -->\n<dependency>\n    <groupId>org.springframework</groupId>\n    <artifactId>spring-webmvc</artifactId>\n    <version>5.2.0.RELEASE</version>\n</dependency>\n<!-- https://mvnrepository.com/artifact/org.springframework/spring-webmvc -->\n<dependency>\n    <groupId>org.springframework</groupId>\n    <artifactId>spring-jdbc</artifactId>\n    <version>5.2.0.RELEASE</version>\n</dependency>\n```\n\n\n\n## 1.2、优点\n\n- Spring是一个开源的免费的框架(容器)！\n- Spring是一个轻量级的、非入侵 式的框架！\n- 控制反转(IOC)，面向切面编程(AOP)！\n- 支持事务的处理，对框架整合的支持！\n\n==总结一句话:Spring就是一个轻量级的控制反转(IOC)和面向切面编程（AOP）的框架！==\n\n\n\n## 1.3组成\n\n![1576133682226](C:\\Users\\guosz\\AppData\\Roaming\\Typora\\typora-user-images\\1576133682226.png)\n\n\n\n## 1.4拓展\n\n在Spring的官网有这个介绍:现代化的java开发!说白就是基于Spring的开发\n\n![1576133880492](C:\\Users\\guosz\\AppData\\Roaming\\Typora\\typora-user-images\\1576133880492.png)\n\n\n\n- Spring Boot\n  - 快速开发的脚手架。\n  - 基于Spring Boot可以快速的开发单个微服务。\n  - 约定大于配置！\n- Spring Cloud\n  - Spring Cloud是基于Spring Boot实现的\n\n因为现在大多数公司都在使用Spring Boot进行快速开发，学习Spring Boot的前提，需要完全掌握Spring及Spring MVC!承上启下的作用!\n\n\n\n**弊端:发展了太久之后,违背了原来的理念!配置十分繁琐，人称配置地狱**\n\n\n\n# 2、IOC理论推导\n\n1.UserDao接口\n\n2.UserDaoImpl实现类\n\n3.UserService业务接口\n\n4.UserServiceImpl 业务实现类\n\n\n\n在我们之前的业务中，用户的需求可能会影响我们原来的代码，我们需要根据用户的需求去修改原代码！如果程序代码量十分大，修改一次的成本代价十分昂贵！\n\n![1576217867883](C:\\Users\\guosz\\AppData\\Roaming\\Typora\\typora-user-images\\1576217867883.png)\n\n我们使用一个Set接口实现. 已经发生了革命性的变化\n\n```java\n private UserDao userDao;\n    //利用set进行动态实现值的注入\n    public  void setUserDao(UserDao userDao) {\n        this.userDao = userDao;\n    }\n```\n\n- 之前，程序是主动创建对象！控制权在程序员手上！\n- 使用set注入后，程序不在具有主动性，而是变成了被动的接受对象!\n\n这种思想，从本质上解决了问题，我们程序员不用再去管理对象的创建了。系统的耦合性大大将达~，可以更加专注的在业务的实现！这是IOC的原型\n\n\n\n![1576217839709](C:\\Users\\guosz\\AppData\\Roaming\\Typora\\typora-user-images\\1576217839709.png)\n\n\n\n\n\n##  IOC本质\n\n控制反转IoC(Inversion of Control)，是一种设计思想，DI(依赖注入)是实现IoC的一种方法**，也有人认为DI只是IoC的另一种说法。没有IoC的程序中 , 我们使用面向对象编程 , 对象的创建与对象间的依赖关系完全硬编码在程序中，对象的创建由程序自己控制，控制反转后将对象的创建转移给第三方，个人认为所谓控制反转就是：获得依赖对象的方式反转了。 \n\n\n\n 采用XML方式配置Bean的时候，Bean的定义信息是和实现分离的，而采用注解的方式可以把两者合为一体，Bean的定义信息直接以注解的形式定义在实现类中，从而达到了零配置的目的。 \n\n **控制反转是一种通过描述（XML或注解）并通过第三方去生产或获取特定对象的方式。在Spring中实现控制反转的是IoC容器，其实现方法是依赖注入（Dependency Injection,DI）。** \n\n\n\n# 3、HelloSpring\n\n## 1.导入Spring相关的jar包\n\n注 : spring 需要导入commons-logging进行日志记录 . 我们利用maven , 他会自动下载对应的依赖项 .\n\n```xml\n<dependency>\n    <groupId>org.springframework</groupId>\n    <artifactId>spring-webmvc</artifactId>\n    <version>5.1.10.RELEASE</version>\n</dependency>\n```\n\n \n\n## 2.编写相关代码\n\n```java\n public class Hello {\n     private String name;\n \n     public String getName() {\n         return name;\n     }\n     public void setName(String name) {\n         this.name = name;\n     }\n \n     public void show(){\n         System.out.println(\"Hello\"+ name );\n     }\n }\n```\n\n \n\n2.2 写编写我们的spring文件 , 这里我们命名为beans.xml\n\n```xml\n   <?xml version=\"1.0\" encoding=\"UTF-8\"?>\n   <beans xmlns=\"http://www.springframework.org/schema/beans\"\n          xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n          xsi:schemaLocation=\"http://www.springframework.org/schema/beans\n           http://www.springframework.org/schema/beans/spring-beans.xsd\">\n   \n       <!--bean就是java对象 , 由Spring创建和管理-->\n       <bean id=\"hello\" class=\"com.kuang.pojo.Hello\">\n          <property name=\"name\" value=\"Spring\"/>\n      </bean>\n  \n  </beans>\n```\n\n \n\n2.3 我们可以去进行测试了 \n\n```java\n @Test\n public void test(){\n     //解析beans.xml文件 , 生成管理相应的Bean对象\n     ApplicationContext context = newClassPathXmlApplicationContext(\"beans.xml\");\n     //getBean : 参数即为spring配置文件中bean的id .\n     Hello hello = (Hello) context.getBean(\"hello\");\n     hello.show();\n }\n```\n\n \n\n### 思考问题 ?\n\n- Hello 对象是谁创建的 ?\n\n  hello 对象是由Spring创建的\n\n- Hello 对象的属性是怎么设置的 ?\n\n  hello 对象的属性是由Spring容器设置的 ,\n\n这个过程就叫控制反转 :\n\n控制 : 谁来控制对象的创建 , 传统应用程序的对象是由程序本身控制创建的 , 使用Spring后 , 对象是由Spring来创建的 .\n\n反转 : 程序本身不创建对象 , 而变成被动的接收对象 .\n\n依赖注入 : 就是利用set方法来进行注入的.\n\nIOC是一种编程思想 , 由主动的编程变成被动的接收 .\n\n可以通过newClassPathXmlApplicationContext去浏览一下底层源码 .\n\n**OK , 到了现在 , 我们彻底不用再程序中去改动了 , 要实现不同的操作 , 只需要在xml配置文件中进行修改 , 所谓的IoC,一句话搞定 : 对象由Spring 来创建 , 管理 , 装配 !**\n\n\n\n# 4.IOC创建对象的方式\n\n1.使用无惨构造创建对象，默认！\n\n2.假设我了吧要使用有参构造创建对象\n\n## 	1.下标赋值\n\n```xml\n<!--第一种下标赋值-->\n<bean id=\"user\" class=\"com.Gosion.pojo.User\">    \n    <constructor-arg index=\"0\" value=\"Gosion学java\"/>\n</bean>\n```\n\n## 	2.类型\n\n```xml\n<!--第二种方式:通过类型创建,不建议使用-->\n    <bean id=\"user\" class=\"com.Gosion.pojo.User\">\n        <constructor-arg type=\"java.lang.String\" value=\"国顺\"/>\n    </bean>\n```\n\n## 	3.通过参数名赋值\n\n```xml\n  <!--第三种 : 直接通过参数名来设置-->\n    <bean id=\"user\" class=\"com.Gosion.pojo.User\">\n        <constructor-arg name=\"name\" value=\"Guoshun\"/>\n    </bean>\n```\n\n\n\n总结:在配置文件中加载的时候，容器中管理的对象就已经初始化了！\n\n\n\n# 5、Spring配置\n\n## 5.1、别名\n\n```xml\n<!--别名,如果添加了别名，我们也可以使用别名来获取这个对象-->\n    <alias name=\"user\" alias=\"usernew\"/>\n```\n\n\n\n## 5.2、Bean的配置\n\n```xml\n    <!--\n    id:bean的唯一标识符，也就是相当于我们学的对象名\n    class:bean  对象所对应的全限定名:包名+类名\n    name: 也是别名,而且name可以同时取多个别名\n    -->\n    <bean id=\"userT\" class=\"com.Gosion.pojo.UserT\" name=\"userT2\">\n\n    </bean>\n```\n\n\n\n\n\n## 5.3 、import\n\n这个import，一般用于团队开发使用，他可以将多个配置文件\n\n假设，现在项目中有多个人开发，这三个人负责不同的类开发，不同的类需要注册在不同的bean中，我们可以利用import将所有人的beans.xml合并为总的！\n\n- 张三\n- 李四\n- 王五\n- applicationContext.xml\n\n```.xml\n <import resource=\"beans.xml\"/>\n    <import resource=\"beans2.xml\"/>\n```\n\n\n\n使用的时候，直接使用中的配置就可以了\n\n\n\n# 6、依赖注入\n\n\n\n## 6.1、构造器注入\n\n前面已经说过了\n\n\n\n## 6.2、Set方式注入【重点】\n\n- 依赖注入:set注入！\n  - 依赖：bean对象的创建依赖于容器\n  - 注入:   bean对象中的所有属性，由容器来注入\n\n\n\n【环境搭建】\n\n​	1.复杂类型\n\n```java\npublic class Address {\n    private String address;\n\n    public String getAddress() {\n        return address;\n    }\n\n    public void setAddress(String address) {\n        this.address = address;\n    }\n}\n```\n\n\n\n​	2.真实测试对象\n\n```java\npublic class Student {\n    private String name;\n    private Address address;\n    private String[] books;\n    private List<String> hobbys;\n    private Map<String,String> card;\n    private Set<String> games;\n    private String wife;\n    private Properties info;\n```\n\n\n\n3.beans.xml\n\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<beans xmlns=\"http://www.springframework.org/schema/beans\"\n       xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n       xsi:schemaLocation=\"http://www.springframework.org/schema/beans\n        https://www.springframework.org/schema/beans/spring-beans.xsd\">\n    <bean id=\"student\" class=\"com.guoshun.pojo.Student\">\n        <!--第一种:普通值注入,value-->\n        <property name=\"name\" value=\"国顺\"/>\n    </bean>\n</beans>\n```\n\n\n\n4.测试类\n\n```java\npublic class MyTest {\n    public static void main(String[] args) {\n        ApplicationContext Context = new ClassPathXmlApplicationContext(\"beans.xml\");\n        Student student = (Student) Context.getBean(\"student\");\n        System.out.printf( student.getName());\n    }\n}\n\n```\n\n\n\n完善注入信息\n\n```xml\n    <bean id=\"address\" class=\"com.guoshun.pojo.Address\">\n        <property name=\"address\" value=\"长沙\"/>\n    </bean>\n    <bean id=\"student\" class=\"com.guoshun.pojo.Student\">\n        <!--第一种:普通值注入,value-->\n        <property name=\"name\" value=\"国顺\"/>\n        <!--第二种bean注入  ref-->\n        <property name=\"address\" ref=\"address\">\n        </property>\n        <!--数组注入-->\n        <property name=\"books\">\n            <array>\n                <value>红楼梦</value>\n                <value>水浒传</value>\n                <value>三国演义</value>\n                <value>西游记</value>\n            </array>\n        </property>\n        <property name=\"hobbys\">\n            <list>\n                <value>听歌</value>\n            </list>\n        </property>\n        <property name=\"card\">\n            <map>\n                <entry key=\"身份证\" value=\"1125457788\"/>\n                <entry key=\"电话\" value=\"191646551\"/>\n            </map>\n        </property>\n        <property name=\"games\">\n            <set>\n                <value>LOL</value>\n                <value>COC</value>\n                <value>BOB</value>\n            </set>\n        </property>\n        <property name=\"wife\">\n            <null/>\n        </property>\n        <property name=\"info\">\n            <props>\n                <prop key=\"driver\">mysql</prop>\n                <prop key=\"url\">root</prop>\n                <prop key=\"password\">985211</prop>\n            </props>\n        </property>\n    </bean>\n```\n\n\n\n## 6.3、拓展方式注入\n\n我们可以使用P命名空间和c命名空间进行注入\n\n官方解释:\n\n使用!\n\n![1576302934268](C:\\Users\\guosz\\AppData\\Roaming\\Typora\\typora-user-images\\1576302934268.png)\n\n测试:\n\n```java\n   @Test\n    public void test2(){\n        ApplicationContext context = new ClassPathXmlApplicationContext(\"userbeans.xml\");\n        User user = (User) context.getBean(\"user\",User.class);\n        System.out.printf( user.toString());\n    }\n```\n\n\n\n注意点:	命名和c命名空间不能直接使用，需要导入XML约束！\n\n```xml\n xmlns:c=\"http://www.springframework.org/schema/c\"\n xmlns:p=\"http://www.springframework.org/schema/p\"\n```\n\n\n\n## 6.4、Bean的作用域\n\n![1576303696640](C:\\Users\\guosz\\AppData\\Roaming\\Typora\\typora-user-images\\1576303696640.png)\n\n\n\n1.单列模式:(Spring默认机制)\n\n```\n<bean id=\"user\" class=\"com.guoshun.pojo.User\" p:name=\"顺哥\" p:age=\"18\" scope=\"singleton\"/>\n```\n\n2.原型模式:每次从容器中get的时候都会产生一个新的对象\n\n```xml\n<bean id=\"accountService\" class=\"com.something.DefaultAccountService\" scope=\"prototype\"/>\n```\n\n3.其余的:request 、Session 、application  这些个只能在Web开发的\n\n\n\n# 7、Bean的自动装配\n\n- 自动装配是Spring满足bean依赖一种方式\n- Spring会在上下文中自动寻找bean，自动给bean装配属性！\n\n在Spring中有三种装配的方式\n\n​	1.在XML中显示的配置\n\n​	2.在java中显示配置\n\n​	3.隐式的自动装配bean【重要!】\n\n\n\n## 7.1、测试\n\n环境搭建:一个人有两个宠物!\n\n\n\n## 7.2、ByName自动装配\n\n```xml\n <!--\n        byName:会自动在容器上下文中查找，和自己对象set方法后面的值对应的bean id！\n        -->\n        <bean id=\"people\" class=\"com.Gosion.pojo.People\" autowire=\"byName\">\n            <property name=\"name\" value=\"靓仔顺\"/>\n        </bean>\n```\n\n\n\n## 7.3、ByType自动装配\n\n```xml\n  <bean id=\"dog\" class=\"com.Gosion.pojo.Dog\"/>\n        <bean id=\"cacdscmdst\" class=\"com.Gosion.pojo.Cat\"/>\n        <!--\n        byName:会自动在容器上下文中查找，和自己对象set方法后面的值对应的bean id！\n        byType:会自动在容器上下文中查找，和自己对象属性类型相同的bean id!\n        -->\n        <bean id=\"people\" class=\"com.Gosion.pojo.People\" autowire=\"byType\">\n            <property name=\"name\" value=\"靓仔顺\"/>\n        </bean>\n```\n\n\n\n小结：\n\n- byname的时候，需要保证所有bean的id唯一，并且这个bean需要和自动注入的属性的set方法发值一致\n- byType的时候，需要保证bean的class唯一，并且这个bean需要和自动注入的属性的类型一致！\n\n\n\n## 7.4、使用注解实现自动装配\n\njdk1.5支持注解,Spring2.5支持注解了！\n\n The introduction of annotation-based configuration raised the question of whether this approach is “better” than XML. \n\n要使用注解须知:\n\n​		1.导入约束。context约束\n\n​		2.配置注解的支持：==<context:annotation-config/>==【重点】\n\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<beans xmlns=\"http://www.springframework.org/schema/beans\"\n    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n    xmlns:context=\"http://www.springframework.org/schema/context\"\n    xsi:schemaLocation=\"http://www.springframework.org/schema/beans\n        https://www.springframework.org/schema/beans/spring-beans.xsd\n        http://www.springframework.org/schema/context\n        https://www.springframework.org/schema/context/spring-context.xsd\">\n\n    <context:annotation-config/>\n\n</beans>\n```\n\n\n\n**@Autowired**\n\n直接在属性上用即可，也可以在Set上使用！\n\n使用@Autowaired我们可以不用编写set方法了，前提是你这个自动装配的属性在IOC(Spring)容器中存在，且符合byname!\n\n科普:\n\n```xml\n@Nullable	字段标记了这个注解,说明这个字段可以为null；\n```\n\n```java\n    //如果显示定义了Autowired的required的属性为false，说明这个对象可以为null否则为空\n    @Autowired(required = false)\n    private Cat cat;\n    @Autowired\n    private Dog dog;\n    private String name;\n```\n\n\n\n如果@Autowired自动装配的环境比较复杂，自动装配无法通过一个注解【@Autowired】完成的时候、我们可以使用@Qualifier(value=\"xxx\")去配合@Autowired的使用，指定一个唯一的对象bean对象注入！\n\n\n\n**@Resouce注解**\n\n需要导入jar包\n\n![1576327301180](C:\\Users\\guosz\\AppData\\Roaming\\Typora\\typora-user-images\\1576327301180.png)\n\n\n\n小结:\n\n@Resouce和@Autowaired区别:\n\n- 都是用来自动装配的，都可以用来放在属性字段上\n- @Autowired通过byname的方式实现，而且必须要求这个对象存在！【常用】\n- @Resource 默认通过byname方式实现，如果找不到名字则通过bytype实现！如果两个都找不到的情况下就报错！【常用】\n- 执行顺序不同:@Autowired byname实现 \n\n\n\n# 8、使用注解开发\n\n在Spring4之后，要使用注解开发，必须要保证aop的包导入了\n\n![1576459409083](C:\\Users\\guosz\\AppData\\Roaming\\Typora\\typora-user-images\\1576459409083.png)\n\n\n\n使用注解需要导入context约束，增加注解支持！\n\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<beans xmlns=\"http://www.springframework.org/schema/beans\"\n    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n    xmlns:context=\"http://www.springframework.org/schema/context\"\n    xsi:schemaLocation=\"http://www.springframework.org/schema/beans\n        https://www.springframework.org/schema/beans/spring-beans.xsd\n        http://www.springframework.org/schema/context\n        https://www.springframework.org/schema/context/spring-context.xsd\">\n\n    <context:annotation-config/>\n\n</beans>\n```\n\n\n\n1.bean\n\n2.属性如何注入\n\n```java\nimport org.springframework.beans.factory.annotation.Value;\nimport org.springframework.stereotype.Component;\n//等价于 <bean id=\"user\" class=\"com.Gosion.pojo.User\">\n//Component 组件\n@Component\npublic class User {\n    //等价于   <property name=\"name\" value=\"gosion\"/>\n    @Value(\"Gosion\")\n    public String name;\n}\n```\n\n3.衍生的注解\n\n@Component有几个衍生注解，在我们web开发中，会按照mvc三层架构分层!\n\n- ​	dao【@Repository】\n\n- service【@Service】\n\n- controller【@Controller】\n\n  这四个注解功能都是一样的，都是代表某个类注册到Spring容器中，装配Bean\n\n4.自动装配\n\n**上面学过了**\n\n5.作用域\n\n```java\nimport org.springframework.beans.factory.annotation.Value;\nimport org.springframework.context.annotation.Scope;\nimport org.springframework.stereotype.Component;\n//等价于 <bean id=\"user\" class=\"com.Gosion.pojo.User\">\n//Component 组件\n@Component\n@Scope(\"prototype\")\npublic class User {\n    //等价于   <property name=\"name\" value=\"gosion\"/>\n    @Value(\"Gosion\")\n    public String name;\n}\n\n```\n\n \n\n6.小结\n\nxml于注解:\n\n- [ ] xml更加万能,使用任何场合,维护简单方便\n- [ ] 注解不是自己的类使用不了，维护相对复杂\n\nxml与注解最佳实践：\n\n- ​	xml用来管理bean\n- 注解只负责完成属性的注入\n- 我们在使用的过程中，只需要注意一个问题：必须让注解生效，就需要开启注解的支持\n\n```xml\n <!--指定要扫描的包，这个包下的注解就会生效-->\n    <context:component-scan base-package=\"com.Gosion\"/>\n    <context:annotation-config/>\n\n```\n\n\n\n# 9、使用java的方式配置Spring\n\n我们现在完全不要使用Spring的xml配置了，全权交给java来做！\n\njavaConfig 是spring的一个子项目,在Spring4之后它变成了核心功能\n\n![1576474773630](C:\\Users\\guosz\\AppData\\Roaming\\Typora\\typora-user-images\\1576474773630.png)\n\n实体类\n\n```java\nimport org.springframework.beans.factory.annotation.Value;\nimport org.springframework.stereotype.Component;\nimport org.springframework.stereotype.Repository;\n//这里这个注解的意思，就是说这个类被Spring接管了，注册到了容器中\n@Component\npublic class User {\n    private String name;\n\n    public String getName() {\n        return name;\n    }\n    @Value(\"guoshun\")//属性注入值\n    public void setName(String name) {\n        this.name = name;\n    }\n}\n\n```\n\n配置类\n\n```java\npackage com.guoshun.config;\n\nimport com.guoshun.pojo.User;\nimport org.springframework.context.annotation.Bean;\nimport org.springframework.context.annotation.ComponentScan;\nimport org.springframework.context.annotation.Configuration;\n\n// Configuration代表这是一个配置类，就和我们之前看的Beans.xml是一样的\n@Configuration//这个也会被Spring容器托管，注册到容器中，因为他本来就是一个@Component，\n@ComponentScan(\"com.guoshun.pojo\")\npublic class GosionConfig {\n    @Bean//注册一个bean，就相当于我们之前写的一个bean标签，\n    //这个方法的名字，就相当与bean标签中的id属性\n    //这个方法的返回值就相当于bean标签的class属性\n    public User getUser(){\n        return new User();//就是返回要返回要注入的对象！\n    }\n}\n\n```\n\n测试类\n\n```java\nimport com.guoshun.config.GosionConfig;\nimport com.guoshun.pojo.User;\nimport org.springframework.context.ApplicationContext;\nimport org.springframework.context.annotation.AnnotationConfigApplicationContext;\n\npublic class MyTest {\n    public static void main(String[] args) {\n        //如果完全使用了配置类方式去做，我们就只能通过AnnotationConfig上下文来获取容器，通过配置类的Class对象加载！\n        ApplicationContext context = new AnnotationConfigApplicationContext(GosionConfig.class);\n        User getUser = (User) context.getBean(\"getUser\");\n        System.out.println(getUser.getName());\n\n\n    }\n}\n```\n\n\n\n这种纯java配置方式，在SpringBoot中随处可见！\n\n\n\n\n\n# 10、代理模式\n\n为什么学代理模式?因为这是Spring AOP的代理层！【SpringAOP和SpringMVC】\n\n代理模式的分类:\n\n- 静态代理\n- 动态代理\n\n![1576477327663](C:\\Users\\guosz\\AppData\\Roaming\\Typora\\typora-user-images\\1576477327663.png)\n\n\n\n## 10.1、代理模式\n\n角色分析:\n\n- 抽象的角色:一般会使用接口或者抽象类来解决\n- 真是角色:被代理的角色\n- 代理角色：代理真是角色，代理真实角色后，我们一般会做一些附属操作\n- 客户:访问代理对象的人\n\n\n\n代码步骤：\n\n​	1.接口\n\n```java\n//租房\npublic interface Rent {\n    public void rent();\n}\n```\n\n​	2.真实角色\n\n```java\n//房东\npublic class Host  implements Rent{\n    @Override\n    public void rent() {\n        System.out.println(\"房东要出租房子\");\n    }\n}\n```\n\n​	3.代理角色\n\n```java\n//代理\npublic class Proxy implements Rent{\n    private Host host;\n\n    public Proxy() {\n    }\n\n    public Proxy(Host host) {\n        this.host = host;\n    }\n\n    @Override\n    public void rent() {\n        seeHouse();\n        host.rent();\n        hetong();\n        fare();\n    }\n    //看房\n    public void seeHouse(){\n        System.out.println(\"中介带你看房\");\n    }\n    //收中介费\n    public  void hetong(){\n        System.out.println(\"签租赁合同\");\n    }\n    //收中介费\n    public  void fare(){\n        System.out.println(\"收中介费\");\n    }\n}\n```\n\n​	4.客户端访问代理角色\n\n```java\npublic class Client {\n    public static void main(String[] args) {\n        //房东要租房子\n        Host host = new Host();\n        //代理 中介帮房东租房子 但是呢 代理角色一般会有一些附属操作\n        Proxy proxy=new Proxy(host);\n        //你不用面对房东，直接找中介租房即可！\n        proxy.rent();\n    }\n}\n```\n\n\n\n\n\n代理模式的好处：\n\n- 可以使真是角色的操作更加纯粹，不用去关注一些公共的业务\n- 公共业务就交给了代理角色,实现了业务的分工！\n- 公共业务发生扩展的时候，方便集中管理！\n\n缺点:\n\n- 一个真实角色就会产生一个代理角色；代码量会翻倍,开发效率会变低\n\n\n\n## 10.2、加深理解\n\n代码对应 08-练习demo2\n\n聊聊AOP\n\n<img src=\"C:\\Users\\guosz\\AppData\\Roaming\\Typora\\typora-user-images\\1576484746469.png\" alt=\"1576484746469\" style=\"zoom: 67%;\" />\n\n\n\n## 10.3、动态代理\n\n- 动态代理，和静态代理角色一样\n- 动态代理的类是动态生成的，不是我们直接写好的\n- 动态代理分为两大类：基于接口的动态代理,基于类的动\n  - 基于接口----JDK动态代理【我们在这了使用】\n  - 基于类：cglib\n  - java字节码实现：javasist\n\n需要了解两个类：Proxy:代理 ,InvocationHandler：调用处理程序\n\n\n\n动态代理的好处:\n\n- 可以使真是角色的操作更加纯粹，不用去关注一些公共的业务\n- 公共业务就交给了代理角色,实现了业务的分工！\n- 公共业务发生扩展的时候，方便集中管理！\n- 一个动态代理类代理的是一个接口，一般就是对应的一类业务\n- 一个动态代理类可以代理多个类，只要实现了同一个接口即可\n\n\n\n# 11、AOP\n\n## 11.1、什么是AOP?\n\n ，AOP为Aspect Oriented Programming的缩写，意为：[面向切面编程](https://baike.baidu.com/item/面向切面编程/6016335)，通过[预编译](https://baike.baidu.com/item/预编译/3191547)方式和运行期动态代理实现程序功能的统一维护的一种技术。AOP是[OOP](https://baike.baidu.com/item/OOP)的延续，是软件开发中的一个热点，也是[Spring](https://baike.baidu.com/item/Spring)框架中的一个重要内容，是[函数式编程](https://baike.baidu.com/item/函数式编程/4035031)的一种衍生范型。利用AOP可以对业务逻辑的各个部分进行隔离，从而使得业务逻辑各部分之间的[耦合度](https://baike.baidu.com/item/耦合度/2603938)降低，提高程序的可重用性，同时提高了开发的效率。 \n\n\n\n\n\n## 11.2、AOP在Spring中的作用\n\n==提供声明事务；允许用户自定义切面==\n\n- 横切关注点：跨越应用程序多个模块的方法或功能，即使，与我们业务逻辑无关的，但我们需要关注分部分，就是横切关注点。如日志，安全，缓存，事务等等\n- 切面:（ASPECT）：切面关注点被模块化的特殊对象。即它是一个类。\n- 通知:(Advice)切面必须要完成的工作\n- 目标(Target):被通知对象\n- 代理（Proxy）:向目标对象应用通知之后创建的对象\n- 切入点(PointCut):切面通知执行的“地点”的定义\n- 连接点（JointPoint）：与切入点匹配的执行点\n\n![1576545392198](C:\\Users\\guosz\\AppData\\Roaming\\Typora\\typora-user-images\\1576545392198.png)\n\nSpringAOP中，通过Advice定义横切逻辑，Spring中支持5种类型的Advice：\n\n<img src=\"C:\\Users\\guosz\\AppData\\Roaming\\Typora\\typora-user-images\\1576568456067.png\" alt=\"1576568456067\" style=\"zoom:67%;\" />\n\n即Aop在不改变原代码的情况下，去增加新的功能\n\n\n\n## 11.3、使用Spring实现AOP\n\n【重点】使用AOP织入，需要导入一个依赖包！\n\n```xml\n<dependency>\n            <groupId>org.aspectj</groupId>\n            <artifactId>aspectjweaver</artifactId>\n            <version>1.9.4</version>\n</dependency>\n```\n\n\n\n\n\n方式一：使用Spring的APl接口 【主要SpringAPI接口实现】\n\n方式二：自定义来实现AOP 【主要是切面定义】\n\n方式三:使用注解实现\n\n\n\n# 12、整合Mybatis\n\n步骤:\n\n1.导入相关jar包\n\n- ​	junit		\n\n- myvatis\n- mysql数据库的\n- spring相关的\n- aop织入\n- mybatis-spring【new 】\n\n2.编写配置文件\n\n3.测试\n\n\n\n## 12.1、回忆mybatis\n\n1. 编写实体类\n\n   \n\n2. 编写核心配置文件\n\n3. 编写接口\n\n4. 编写Mapper.xml\n\n5. 测试\n\n\n\n## 12.2、mybatis-spring\n\n\n\n1. 编写数据源配置\n\n   ```xml\n       <!--DataSource :使用Spring的数据源替换mybatis的配置\n       我们这里使用Spring提供的JDBC\n       -->\n       <bean id=\"dataSource\" class=\"org.springframework.jdbc.datasource.DriverManagerDataSource\">\n           <property name=\"driverClassName\" value=\"com.mysql.jdbc.Driver\"/>\n           <property name=\"url\" value=\"jdbc:mysql:///mybatis\"/>\n           <property name=\"username\" value=\"root\"/>\n           <property name=\"password\" value=\"985211\"/>\n       </bean>\n   ```\n\n2. SqlSessionFactory\n\n   ```xml\n      <!--SqlSessionFactory-->\n       <bean id=\"sqlSessionFactory\" class=\"org.mybatis.spring.SqlSessionFactoryBean\">\n           <property name=\"dataSource\" ref=\"dataSource\" />\n           <!--绑定Mybatis配置文件-->\n           <property name=\"configLocation\" value=\"classpath:mybatis-config.xml\"/>\n           <property name=\"mapperLocations\" value=\"classpath:com/Gosion/Mapper/UserMapper.xml\"/>\n       </bean>\n   ```\n\n3. SqlSessionTemplate\n\n   ```xml\n       <!--SqlSessionTemplate 就是我们使用的SqlSession-->\n       <bean id=\"SqlSession\" class=\"org.mybatis.spring.SqlSessionTemplate\">\n           <!--只能使用构造器注入，因为他没有set方法-->\n               <constructor-arg index=\"0\" ref=\"sqlSessionFactory\"/>\n       </bean>\n   ```\n\n4. 需要给接口加实现类\n\n   ```java\n   import com.Gosion.pojo.User;\n   import org.mybatis.spring.SqlSessionTemplate;\n   \n   import java.util.List;\n   \n   public class USerMapperImpl  implements UserMapper{\n       private SqlSessionTemplate sqlSession;\n   \n       public void setSqlSession(SqlSessionTemplate sqlSession) {\n           this.sqlSession = sqlSession;\n       }\n   \n       //我们的所有操作，都使用sqlSession来执行，在原来，现在都是使用SqlSessionTemplate\n       public List<User> selectUser() {\n   \n           UserMapper mapper = sqlSession.getMapper(UserMapper.class);\n           return mapper.selectUser();\n       }\n   }\n   \n   ```\n\n5. 将自己写的实现类，注入到spring中\n\n   ```xml\n      <!---->\n       <bean id=\"userMapper\" class=\"com.Gosion.Mapper.USerMapperImpl\">\n           <property name=\"sqlSession\" ref=\"SqlSession\"/>\n       </bean>\n   ```\n\n6. 测试即可\n\n```java\nimport com.Gosion.Mapper.UserMapper;\nimport com.Gosion.pojo.User;\nimport org.junit.Test;\nimport org.springframework.context.ApplicationContext;\nimport org.springframework.context.support.ClassPathXmlApplicationContext;\n\nimport java.io.IOException;\n\npublic class MyTest {\n    @Test\n    public void test() throws IOException {\n       ApplicationContext context = new ClassPathXmlApplicationContext(\"applicationContext.xml\");\n        UserMapper userMapper = context.getBean(\"userMapper\", UserMapper.class);\n        for (User user : userMapper.selectUser()) {\n            System.out.println(user);\n        }\n    }\n}\n```\n\nspring-dao\n\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<beans xmlns=\"http://www.springframework.org/schema/beans\"\n       xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n       xmlns:aop=\"http://www.springframework.org/schema/aop\"\n       xsi:schemaLocation=\"http://www.springframework.org/schema/beans\n        https://www.springframework.org/schema/beans/spring-beans.xsd\n         http://www.springframework.org/schema/aop\n        https://www.springframework.org/schema/aop/spring-aop.xsd\">\n\n  <!--dataSource-->\n    <bean id=\"dataSource\" class=\"org.springframework.jdbc.datasource.DriverManagerDataSource\">\n        <property name=\"driverClassName\" value=\"com.mysql.jdbc.Driver\"/>\n        <property name=\"url\" value=\"jdbc:mysql://localhost:3306/mybatis?serverTimezone=GMT%2B8&amp;useSSL=false\"/>\n        <property name=\"username\" value=\"root\"/>\n        <property name=\"password\" value=\"985211\"/>\n    </bean>\n    <!--SqlSessionFactory-->\n    <bean id=\"sqlSessionFactory\" class=\"org.mybatis.spring.SqlSessionFactoryBean\">\n        <property name=\"dataSource\" ref=\"dataSource\" />\n\n        <property name=\"configLocation\" value=\"classpath:mybatis-config.xml\"/>\n        <property name=\"mapperLocations\" value=\"classpath:com/Gosion/Mapper/UserMapper.xml\"/>\n    </bean>\n    <bean id=\"SqlSession\" class=\"org.mybatis.spring.SqlSessionTemplate\">\n        <constructor-arg index=\"0\" ref=\"sqlSessionFactory\"/>\n    </bean>\n\n    <bean id=\"userMapper\" class=\"com.Gosion.Mapper.UserMapperImpl\">\n        <property name=\"sqlSession\" ref=\"SqlSession\"/>\n    </bean>\n\n</beans>\n```\n\n==整合需要的jar包==\n\n```xml\n<dependencies>\n    <dependency>\n        <groupId>mysql</groupId>\n        <artifactId>mysql-connector-java</artifactId>\n        <version>8.0.11</version>\n    </dependency>\n\n    <dependency>\n        <groupId>org.mybatis</groupId>\n        <artifactId>mybatis</artifactId>\n        <version>3.5.2</version>\n    </dependency>\n\n    <dependency>\n        <groupId>junit</groupId>\n        <artifactId>junit</artifactId>\n        <version>4.12</version>\n    </dependency>\n\n    <dependency>\n        <groupId>org.mybatis</groupId>\n        <artifactId>mybatis-spring</artifactId>\n        <version>2.0.3</version>\n    </dependency>\n\n    <dependency>\n        <groupId>org.springframework</groupId>\n        <artifactId>spring-webmvc</artifactId>\n        <version>5.2.2.RELEASE</version>\n    </dependency>\n\n    <dependency>\n        <groupId>org.springframework</groupId>\n        <artifactId>spring-jdbc</artifactId>\n        <version>5.2.2.RELEASE</version>\n    </dependency>\n    <dependency>\n        <groupId>org.aspectj</groupId>\n        <artifactId>aspectjweaver</artifactId>\n        <version>1.9.4</version>\n    </dependency>\n    <dependency>\n        <groupId>org.projectlombok</groupId>\n        <artifactId>lombok</artifactId>\n        <version>1.18.10</version>\n        <scope>provided</scope>\n    </dependency>\n    <dependency>\n        <groupId>org.springframework</groupId>\n        <artifactId>spring-context</artifactId>\n        <version>5.2.2.RELEASE</version>\n        <scope>test</scope>\n    </dependency>\n</dependencies>\n```\n\n\n\n# 13、声明式事务\n\n\n\n## 1、回顾事务\n\n- 把一组业务当成一个业务来做；要么都成功，要么都失败！\n- 事务在项目开发中十分重要，涉及到数据的一致性问题，不能马虎！\n- 确保完整性，和一致性；\n\n\n\n事务的ACID原则:\n\n- 原子性\n- 一致性\n- 隔离性\n  - 多个业务可能操作同一个资源，防止数据损坏\n- 持久性\n  - 事务一旦提交，无论系统出什么问题，结果都不会再被影响，被持久化的写到存储器中!\n\n## 2、Spring中的事务管理\n\n- 声明式事务：AOP\n- 编程式事务：需要在代码中，进行事务的管理\n\n思考:\n\n为什么需要事务?\n\n- 如果不配置事务，可能存在数据提交不一致的情况下；\n- 如果我们不在Sping中去声明事务，我门就需要在代码中手动配置事务！\n- 事务在项目的开发中十分重要，设计到一致性和完整性问题，不容马虎\n\n\n\n\n\n\n\n\n\n', NULL, 0, 0, 0, NULL, '2020-12-23', 320, NULL, 102);
INSERT INTO `tb_article` VALUES (27, 21, 'hello', '', '1 Spring     1 1简介  - Spring 春天---------- 给原件行业带来春天 - 2002 首次推出了Spring框架雏形 interface21框架 - 2004年3月24号Spring发布了1 0正式版 - Rod Johnson   Spring Framework创始人  著名作者  很难想象Rod Johnson的学历 真的让好多人大吃一惊 他是 悉尼大学  https   baike baidu com item 悉尼大学 的博士 然而他的专业不是计算机 而是音乐学   - Spring理念 使现有的技术更加容易使用 本身是一个大杂烩 整合了现有的技术框架', '', '\n\n\n\n# 1、Spring\n\n## 1.1简介\n\n- Spring：春天---------->给原件行业带来春天\n- 2002,首次推出了Spring框架雏形:interface21框架\n- 2004年3月24号Spring发布了1.0正式版\n- Rod Johnson ， Spring Framework创始人 ，著名作者。 很难想象Rod Johnson的学历，真的让好多人大吃一惊，他是[悉尼大学](https://baike.baidu.com/item/悉尼大学)的博士，然而他的专业不是计算机，而是音乐学。 \n- Spring理念：使现有的技术更加容易使用，本身是一个大杂烩，整合了现有的技术框架！\n\n\n\n- SSH :	Struct2+Spring+Hibernate!\n- SSM：  SpringMVC+Spring+Mybatis!\n\n- 官网: https://spring.io/projects/spring-framework \n- 官方下载地址: [http://repo.spring.io/release/org/springframework/spring](https://repo.spring.io/release/org/springframework/spring)  \n- GitHub: https://github.com/spring-projects/spring-framework \n\n```xml\n<!-- https://mvnrepository.com/artifact/org.springframework/spring-webmvc -->\n<dependency>\n    <groupId>org.springframework</groupId>\n    <artifactId>spring-webmvc</artifactId>\n    <version>5.2.0.RELEASE</version>\n</dependency>\n<!-- https://mvnrepository.com/artifact/org.springframework/spring-webmvc -->\n<dependency>\n    <groupId>org.springframework</groupId>\n    <artifactId>spring-jdbc</artifactId>\n    <version>5.2.0.RELEASE</version>\n</dependency>\n```\n\n\n\n## 1.2、优点\n\n- Spring是一个开源的免费的框架(容器)！\n- Spring是一个轻量级的、非入侵 式的框架！\n- 控制反转(IOC)，面向切面编程(AOP)！\n- 支持事务的处理，对框架整合的支持！\n\n==总结一句话:Spring就是一个轻量级的控制反转(IOC)和面向切面编程（AOP）的框架！==\n\n\n\n## 1.3组成\n\n![1576133682226](C:\\Users\\guosz\\AppData\\Roaming\\Typora\\typora-user-images\\1576133682226.png)\n\n\n\n## 1.4拓展\n\n在Spring的官网有这个介绍:现代化的java开发!说白就是基于Spring的开发\n\n![1576133880492](C:\\Users\\guosz\\AppData\\Roaming\\Typora\\typora-user-images\\1576133880492.png)\n\n\n\n- Spring Boot\n  - 快速开发的脚手架。\n  - 基于Spring Boot可以快速的开发单个微服务。\n  - 约定大于配置！\n- Spring Cloud\n  - Spring Cloud是基于Spring Boot实现的\n\n因为现在大多数公司都在使用Spring Boot进行快速开发，学习Spring Boot的前提，需要完全掌握Spring及Spring MVC!承上启下的作用!\n\n\n\n**弊端:发展了太久之后,违背了原来的理念!配置十分繁琐，人称配置地狱**\n\n\n\n# 2、IOC理论推导\n\n1.UserDao接口\n\n2.UserDaoImpl实现类\n\n3.UserService业务接口\n\n4.UserServiceImpl 业务实现类\n\n\n\n在我们之前的业务中，用户的需求可能会影响我们原来的代码，我们需要根据用户的需求去修改原代码！如果程序代码量十分大，修改一次的成本代价十分昂贵！\n\n![1576217867883](C:\\Users\\guosz\\AppData\\Roaming\\Typora\\typora-user-images\\1576217867883.png)\n\n我们使用一个Set接口实现. 已经发生了革命性的变化\n\n```java\n private UserDao userDao;\n    //利用set进行动态实现值的注入\n    public  void setUserDao(UserDao userDao) {\n        this.userDao = userDao;\n    }\n```\n\n- 之前，程序是主动创建对象！控制权在程序员手上！\n- 使用set注入后，程序不在具有主动性，而是变成了被动的接受对象!\n\n这种思想，从本质上解决了问题，我们程序员不用再去管理对象的创建了。系统的耦合性大大将达~，可以更加专注的在业务的实现！这是IOC的原型\n\n\n\n![1576217839709](C:\\Users\\guosz\\AppData\\Roaming\\Typora\\typora-user-images\\1576217839709.png)\n\n\n\n\n\n##  IOC本质\n\n控制反转IoC(Inversion of Control)，是一种设计思想，DI(依赖注入)是实现IoC的一种方法**，也有人认为DI只是IoC的另一种说法。没有IoC的程序中 , 我们使用面向对象编程 , 对象的创建与对象间的依赖关系完全硬编码在程序中，对象的创建由程序自己控制，控制反转后将对象的创建转移给第三方，个人认为所谓控制反转就是：获得依赖对象的方式反转了。 \n\n\n\n 采用XML方式配置Bean的时候，Bean的定义信息是和实现分离的，而采用注解的方式可以把两者合为一体，Bean的定义信息直接以注解的形式定义在实现类中，从而达到了零配置的目的。 \n\n **控制反转是一种通过描述（XML或注解）并通过第三方去生产或获取特定对象的方式。在Spring中实现控制反转的是IoC容器，其实现方法是依赖注入（Dependency Injection,DI）。** \n\n\n\n# 3、HelloSpring\n\n## 1.导入Spring相关的jar包\n\n注 : spring 需要导入commons-logging进行日志记录 . 我们利用maven , 他会自动下载对应的依赖项 .\n\n```xml\n<dependency>\n    <groupId>org.springframework</groupId>\n    <artifactId>spring-webmvc</artifactId>\n    <version>5.1.10.RELEASE</version>\n</dependency>\n```\n\n \n\n## 2.编写相关代码\n\n```java\n public class Hello {\n     private String name;\n \n     public String getName() {\n         return name;\n     }\n     public void setName(String name) {\n         this.name = name;\n     }\n \n     public void show(){\n         System.out.println(\"Hello\"+ name );\n     }\n }\n```\n\n \n\n2.2 写编写我们的spring文件 , 这里我们命名为beans.xml\n\n```xml\n   <?xml version=\"1.0\" encoding=\"UTF-8\"?>\n   <beans xmlns=\"http://www.springframework.org/schema/beans\"\n          xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n          xsi:schemaLocation=\"http://www.springframework.org/schema/beans\n           http://www.springframework.org/schema/beans/spring-beans.xsd\">\n   \n       <!--bean就是java对象 , 由Spring创建和管理-->\n       <bean id=\"hello\" class=\"com.kuang.pojo.Hello\">\n          <property name=\"name\" value=\"Spring\"/>\n      </bean>\n  \n  </beans>\n```\n\n \n\n2.3 我们可以去进行测试了 \n\n```java\n @Test\n public void test(){\n     //解析beans.xml文件 , 生成管理相应的Bean对象\n     ApplicationContext context = newClassPathXmlApplicationContext(\"beans.xml\");\n     //getBean : 参数即为spring配置文件中bean的id .\n     Hello hello = (Hello) context.getBean(\"hello\");\n     hello.show();\n }\n```\n\n \n\n### 思考问题 ?\n\n- Hello 对象是谁创建的 ?\n\n  hello 对象是由Spring创建的\n\n- Hello 对象的属性是怎么设置的 ?\n\n  hello 对象的属性是由Spring容器设置的 ,\n\n这个过程就叫控制反转 :\n\n控制 : 谁来控制对象的创建 , 传统应用程序的对象是由程序本身控制创建的 , 使用Spring后 , 对象是由Spring来创建的 .\n\n反转 : 程序本身不创建对象 , 而变成被动的接收对象 .\n\n依赖注入 : 就是利用set方法来进行注入的.\n\nIOC是一种编程思想 , 由主动的编程变成被动的接收 .\n\n可以通过newClassPathXmlApplicationContext去浏览一下底层源码 .\n\n**OK , 到了现在 , 我们彻底不用再程序中去改动了 , 要实现不同的操作 , 只需要在xml配置文件中进行修改 , 所谓的IoC,一句话搞定 : 对象由Spring 来创建 , 管理 , 装配 !**\n\n\n\n# 4.IOC创建对象的方式\n\n1.使用无惨构造创建对象，默认！\n\n2.假设我了吧要使用有参构造创建对象\n\n## 	1.下标赋值\n\n```xml\n<!--第一种下标赋值-->\n<bean id=\"user\" class=\"com.Gosion.pojo.User\">    \n    <constructor-arg index=\"0\" value=\"Gosion学java\"/>\n</bean>\n```\n\n## 	2.类型\n\n```xml\n<!--第二种方式:通过类型创建,不建议使用-->\n    <bean id=\"user\" class=\"com.Gosion.pojo.User\">\n        <constructor-arg type=\"java.lang.String\" value=\"国顺\"/>\n    </bean>\n```\n\n## 	3.通过参数名赋值\n\n```xml\n  <!--第三种 : 直接通过参数名来设置-->\n    <bean id=\"user\" class=\"com.Gosion.pojo.User\">\n        <constructor-arg name=\"name\" value=\"Guoshun\"/>\n    </bean>\n```\n\n\n\n总结:在配置文件中加载的时候，容器中管理的对象就已经初始化了！\n\n\n\n# 5、Spring配置\n\n## 5.1、别名\n\n```xml\n<!--别名,如果添加了别名，我们也可以使用别名来获取这个对象-->\n    <alias name=\"user\" alias=\"usernew\"/>\n```\n\n\n\n## 5.2、Bean的配置\n\n```xml\n    <!--\n    id:bean的唯一标识符，也就是相当于我们学的对象名\n    class:bean  对象所对应的全限定名:包名+类名\n    name: 也是别名,而且name可以同时取多个别名\n    -->\n    <bean id=\"userT\" class=\"com.Gosion.pojo.UserT\" name=\"userT2\">\n\n    </bean>\n```\n\n\n\n\n\n## 5.3 、import\n\n这个import，一般用于团队开发使用，他可以将多个配置文件\n\n假设，现在项目中有多个人开发，这三个人负责不同的类开发，不同的类需要注册在不同的bean中，我们可以利用import将所有人的beans.xml合并为总的！\n\n- 张三\n- 李四\n- 王五\n- applicationContext.xml\n\n```.xml\n <import resource=\"beans.xml\"/>\n    <import resource=\"beans2.xml\"/>\n```\n\n\n\n使用的时候，直接使用中的配置就可以了\n\n\n\n# 6、依赖注入\n\n\n\n## 6.1、构造器注入\n\n前面已经说过了\n\n\n\n## 6.2、Set方式注入【重点】\n\n- 依赖注入:set注入！\n  - 依赖：bean对象的创建依赖于容器\n  - 注入:   bean对象中的所有属性，由容器来注入\n\n\n\n【环境搭建】\n\n​	1.复杂类型\n\n```java\npublic class Address {\n    private String address;\n\n    public String getAddress() {\n        return address;\n    }\n\n    public void setAddress(String address) {\n        this.address = address;\n    }\n}\n```\n\n\n\n​	2.真实测试对象\n\n```java\npublic class Student {\n    private String name;\n    private Address address;\n    private String[] books;\n    private List<String> hobbys;\n    private Map<String,String> card;\n    private Set<String> games;\n    private String wife;\n    private Properties info;\n```\n\n\n\n3.beans.xml\n\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<beans xmlns=\"http://www.springframework.org/schema/beans\"\n       xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n       xsi:schemaLocation=\"http://www.springframework.org/schema/beans\n        https://www.springframework.org/schema/beans/spring-beans.xsd\">\n    <bean id=\"student\" class=\"com.guoshun.pojo.Student\">\n        <!--第一种:普通值注入,value-->\n        <property name=\"name\" value=\"国顺\"/>\n    </bean>\n</beans>\n```\n\n\n\n4.测试类\n\n```java\npublic class MyTest {\n    public static void main(String[] args) {\n        ApplicationContext Context = new ClassPathXmlApplicationContext(\"beans.xml\");\n        Student student = (Student) Context.getBean(\"student\");\n        System.out.printf( student.getName());\n    }\n}\n\n```\n\n\n\n完善注入信息\n\n```xml\n    <bean id=\"address\" class=\"com.guoshun.pojo.Address\">\n        <property name=\"address\" value=\"长沙\"/>\n    </bean>\n    <bean id=\"student\" class=\"com.guoshun.pojo.Student\">\n        <!--第一种:普通值注入,value-->\n        <property name=\"name\" value=\"国顺\"/>\n        <!--第二种bean注入  ref-->\n        <property name=\"address\" ref=\"address\">\n        </property>\n        <!--数组注入-->\n        <property name=\"books\">\n            <array>\n                <value>红楼梦</value>\n                <value>水浒传</value>\n                <value>三国演义</value>\n                <value>西游记</value>\n            </array>\n        </property>\n        <property name=\"hobbys\">\n            <list>\n                <value>听歌</value>\n            </list>\n        </property>\n        <property name=\"card\">\n            <map>\n                <entry key=\"身份证\" value=\"1125457788\"/>\n                <entry key=\"电话\" value=\"191646551\"/>\n            </map>\n        </property>\n        <property name=\"games\">\n            <set>\n                <value>LOL</value>\n                <value>COC</value>\n                <value>BOB</value>\n            </set>\n        </property>\n        <property name=\"wife\">\n            <null/>\n        </property>\n        <property name=\"info\">\n            <props>\n                <prop key=\"driver\">mysql</prop>\n                <prop key=\"url\">root</prop>\n                <prop key=\"password\">985211</prop>\n            </props>\n        </property>\n    </bean>\n```\n\n\n\n## 6.3、拓展方式注入\n\n我们可以使用P命名空间和c命名空间进行注入\n\n官方解释:\n\n使用!\n\n![1576302934268](C:\\Users\\guosz\\AppData\\Roaming\\Typora\\typora-user-images\\1576302934268.png)\n\n测试:\n\n```java\n   @Test\n    public void test2(){\n        ApplicationContext context = new ClassPathXmlApplicationContext(\"userbeans.xml\");\n        User user = (User) context.getBean(\"user\",User.class);\n        System.out.printf( user.toString());\n    }\n```\n\n\n\n注意点:	命名和c命名空间不能直接使用，需要导入XML约束！\n\n```xml\n xmlns:c=\"http://www.springframework.org/schema/c\"\n xmlns:p=\"http://www.springframework.org/schema/p\"\n```\n\n\n\n## 6.4、Bean的作用域\n\n![1576303696640](C:\\Users\\guosz\\AppData\\Roaming\\Typora\\typora-user-images\\1576303696640.png)\n\n\n\n1.单列模式:(Spring默认机制)\n\n```\n<bean id=\"user\" class=\"com.guoshun.pojo.User\" p:name=\"顺哥\" p:age=\"18\" scope=\"singleton\"/>\n```\n\n2.原型模式:每次从容器中get的时候都会产生一个新的对象\n\n```xml\n<bean id=\"accountService\" class=\"com.something.DefaultAccountService\" scope=\"prototype\"/>\n```\n\n3.其余的:request 、Session 、application  这些个只能在Web开发的\n\n\n\n# 7、Bean的自动装配\n\n- 自动装配是Spring满足bean依赖一种方式\n- Spring会在上下文中自动寻找bean，自动给bean装配属性！\n\n在Spring中有三种装配的方式\n\n​	1.在XML中显示的配置\n\n​	2.在java中显示配置\n\n​	3.隐式的自动装配bean【重要!】\n\n\n\n## 7.1、测试\n\n环境搭建:一个人有两个宠物!\n\n\n\n## 7.2、ByName自动装配\n\n```xml\n <!--\n        byName:会自动在容器上下文中查找，和自己对象set方法后面的值对应的bean id！\n        -->\n        <bean id=\"people\" class=\"com.Gosion.pojo.People\" autowire=\"byName\">\n            <property name=\"name\" value=\"靓仔顺\"/>\n        </bean>\n```\n\n\n\n## 7.3、ByType自动装配\n\n```xml\n  <bean id=\"dog\" class=\"com.Gosion.pojo.Dog\"/>\n        <bean id=\"cacdscmdst\" class=\"com.Gosion.pojo.Cat\"/>\n        <!--\n        byName:会自动在容器上下文中查找，和自己对象set方法后面的值对应的bean id！\n        byType:会自动在容器上下文中查找，和自己对象属性类型相同的bean id!\n        -->\n        <bean id=\"people\" class=\"com.Gosion.pojo.People\" autowire=\"byType\">\n            <property name=\"name\" value=\"靓仔顺\"/>\n        </bean>\n```\n\n\n\n小结：\n\n- byname的时候，需要保证所有bean的id唯一，并且这个bean需要和自动注入的属性的set方法发值一致\n- byType的时候，需要保证bean的class唯一，并且这个bean需要和自动注入的属性的类型一致！\n\n\n\n## 7.4、使用注解实现自动装配\n\njdk1.5支持注解,Spring2.5支持注解了！\n\n The introduction of annotation-based configuration raised the question of whether this approach is “better” than XML. \n\n要使用注解须知:\n\n​		1.导入约束。context约束\n\n​		2.配置注解的支持：==<context:annotation-config/>==【重点】\n\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<beans xmlns=\"http://www.springframework.org/schema/beans\"\n    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n    xmlns:context=\"http://www.springframework.org/schema/context\"\n    xsi:schemaLocation=\"http://www.springframework.org/schema/beans\n        https://www.springframework.org/schema/beans/spring-beans.xsd\n        http://www.springframework.org/schema/context\n        https://www.springframework.org/schema/context/spring-context.xsd\">\n\n    <context:annotation-config/>\n\n</beans>\n```\n\n\n\n**@Autowired**\n\n直接在属性上用即可，也可以在Set上使用！\n\n使用@Autowaired我们可以不用编写set方法了，前提是你这个自动装配的属性在IOC(Spring)容器中存在，且符合byname!\n\n科普:\n\n```xml\n@Nullable	字段标记了这个注解,说明这个字段可以为null；\n```\n\n```java\n    //如果显示定义了Autowired的required的属性为false，说明这个对象可以为null否则为空\n    @Autowired(required = false)\n    private Cat cat;\n    @Autowired\n    private Dog dog;\n    private String name;\n```\n\n\n\n如果@Autowired自动装配的环境比较复杂，自动装配无法通过一个注解【@Autowired】完成的时候、我们可以使用@Qualifier(value=\"xxx\")去配合@Autowired的使用，指定一个唯一的对象bean对象注入！\n\n\n\n**@Resouce注解**\n\n需要导入jar包\n\n![1576327301180](C:\\Users\\guosz\\AppData\\Roaming\\Typora\\typora-user-images\\1576327301180.png)\n\n\n\n小结:\n\n@Resouce和@Autowaired区别:\n\n- 都是用来自动装配的，都可以用来放在属性字段上\n- @Autowired通过byname的方式实现，而且必须要求这个对象存在！【常用】\n- @Resource 默认通过byname方式实现，如果找不到名字则通过bytype实现！如果两个都找不到的情况下就报错！【常用】\n- 执行顺序不同:@Autowired byname实现 \n\n\n\n# 8、使用注解开发\n\n在Spring4之后，要使用注解开发，必须要保证aop的包导入了\n\n![1576459409083](C:\\Users\\guosz\\AppData\\Roaming\\Typora\\typora-user-images\\1576459409083.png)\n\n\n\n使用注解需要导入context约束，增加注解支持！\n\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<beans xmlns=\"http://www.springframework.org/schema/beans\"\n    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n    xmlns:context=\"http://www.springframework.org/schema/context\"\n    xsi:schemaLocation=\"http://www.springframework.org/schema/beans\n        https://www.springframework.org/schema/beans/spring-beans.xsd\n        http://www.springframework.org/schema/context\n        https://www.springframework.org/schema/context/spring-context.xsd\">\n\n    <context:annotation-config/>\n\n</beans>\n```\n\n\n\n1.bean\n\n2.属性如何注入\n\n```java\nimport org.springframework.beans.factory.annotation.Value;\nimport org.springframework.stereotype.Component;\n//等价于 <bean id=\"user\" class=\"com.Gosion.pojo.User\">\n//Component 组件\n@Component\npublic class User {\n    //等价于   <property name=\"name\" value=\"gosion\"/>\n    @Value(\"Gosion\")\n    public String name;\n}\n```\n\n3.衍生的注解\n\n@Component有几个衍生注解，在我们web开发中，会按照mvc三层架构分层!\n\n- ​	dao【@Repository】\n\n- service【@Service】\n\n- controller【@Controller】\n\n  这四个注解功能都是一样的，都是代表某个类注册到Spring容器中，装配Bean\n\n4.自动装配\n\n**上面学过了**\n\n5.作用域\n\n```java\nimport org.springframework.beans.factory.annotation.Value;\nimport org.springframework.context.annotation.Scope;\nimport org.springframework.stereotype.Component;\n//等价于 <bean id=\"user\" class=\"com.Gosion.pojo.User\">\n//Component 组件\n@Component\n@Scope(\"prototype\")\npublic class User {\n    //等价于   <property name=\"name\" value=\"gosion\"/>\n    @Value(\"Gosion\")\n    public String name;\n}\n\n```\n\n \n\n6.小结\n\nxml于注解:\n\n- [ ] xml更加万能,使用任何场合,维护简单方便\n- [ ] 注解不是自己的类使用不了，维护相对复杂\n\nxml与注解最佳实践：\n\n- ​	xml用来管理bean\n- 注解只负责完成属性的注入\n- 我们在使用的过程中，只需要注意一个问题：必须让注解生效，就需要开启注解的支持\n\n```xml\n <!--指定要扫描的包，这个包下的注解就会生效-->\n    <context:component-scan base-package=\"com.Gosion\"/>\n    <context:annotation-config/>\n\n```\n\n\n\n# 9、使用java的方式配置Spring\n\n我们现在完全不要使用Spring的xml配置了，全权交给java来做！\n\njavaConfig 是spring的一个子项目,在Spring4之后它变成了核心功能\n\n![1576474773630](C:\\Users\\guosz\\AppData\\Roaming\\Typora\\typora-user-images\\1576474773630.png)\n\n实体类\n\n```java\nimport org.springframework.beans.factory.annotation.Value;\nimport org.springframework.stereotype.Component;\nimport org.springframework.stereotype.Repository;\n//这里这个注解的意思，就是说这个类被Spring接管了，注册到了容器中\n@Component\npublic class User {\n    private String name;\n\n    public String getName() {\n        return name;\n    }\n    @Value(\"guoshun\")//属性注入值\n    public void setName(String name) {\n        this.name = name;\n    }\n}\n\n```\n\n配置类\n\n```java\npackage com.guoshun.config;\n\nimport com.guoshun.pojo.User;\nimport org.springframework.context.annotation.Bean;\nimport org.springframework.context.annotation.ComponentScan;\nimport org.springframework.context.annotation.Configuration;\n\n// Configuration代表这是一个配置类，就和我们之前看的Beans.xml是一样的\n@Configuration//这个也会被Spring容器托管，注册到容器中，因为他本来就是一个@Component，\n@ComponentScan(\"com.guoshun.pojo\")\npublic class GosionConfig {\n    @Bean//注册一个bean，就相当于我们之前写的一个bean标签，\n    //这个方法的名字，就相当与bean标签中的id属性\n    //这个方法的返回值就相当于bean标签的class属性\n    public User getUser(){\n        return new User();//就是返回要返回要注入的对象！\n    }\n}\n\n```\n\n测试类\n\n```java\nimport com.guoshun.config.GosionConfig;\nimport com.guoshun.pojo.User;\nimport org.springframework.context.ApplicationContext;\nimport org.springframework.context.annotation.AnnotationConfigApplicationContext;\n\npublic class MyTest {\n    public static void main(String[] args) {\n        //如果完全使用了配置类方式去做，我们就只能通过AnnotationConfig上下文来获取容器，通过配置类的Class对象加载！\n        ApplicationContext context = new AnnotationConfigApplicationContext(GosionConfig.class);\n        User getUser = (User) context.getBean(\"getUser\");\n        System.out.println(getUser.getName());\n\n\n    }\n}\n```\n\n\n\n这种纯java配置方式，在SpringBoot中随处可见！\n\n\n\n\n\n# 10、代理模式\n\n为什么学代理模式?因为这是Spring AOP的代理层！【SpringAOP和SpringMVC】\n\n代理模式的分类:\n\n- 静态代理\n- 动态代理\n\n![1576477327663](C:\\Users\\guosz\\AppData\\Roaming\\Typora\\typora-user-images\\1576477327663.png)\n\n\n\n## 10.1、代理模式\n\n角色分析:\n\n- 抽象的角色:一般会使用接口或者抽象类来解决\n- 真是角色:被代理的角色\n- 代理角色：代理真是角色，代理真实角色后，我们一般会做一些附属操作\n- 客户:访问代理对象的人\n\n\n\n代码步骤：\n\n​	1.接口\n\n```java\n//租房\npublic interface Rent {\n    public void rent();\n}\n```\n\n​	2.真实角色\n\n```java\n//房东\npublic class Host  implements Rent{\n    @Override\n    public void rent() {\n        System.out.println(\"房东要出租房子\");\n    }\n}\n```\n\n​	3.代理角色\n\n```java\n//代理\npublic class Proxy implements Rent{\n    private Host host;\n\n    public Proxy() {\n    }\n\n    public Proxy(Host host) {\n        this.host = host;\n    }\n\n    @Override\n    public void rent() {\n        seeHouse();\n        host.rent();\n        hetong();\n        fare();\n    }\n    //看房\n    public void seeHouse(){\n        System.out.println(\"中介带你看房\");\n    }\n    //收中介费\n    public  void hetong(){\n        System.out.println(\"签租赁合同\");\n    }\n    //收中介费\n    public  void fare(){\n        System.out.println(\"收中介费\");\n    }\n}\n```\n\n​	4.客户端访问代理角色\n\n```java\npublic class Client {\n    public static void main(String[] args) {\n        //房东要租房子\n        Host host = new Host();\n        //代理 中介帮房东租房子 但是呢 代理角色一般会有一些附属操作\n        Proxy proxy=new Proxy(host);\n        //你不用面对房东，直接找中介租房即可！\n        proxy.rent();\n    }\n}\n```\n\n\n\n\n\n代理模式的好处：\n\n- 可以使真是角色的操作更加纯粹，不用去关注一些公共的业务\n- 公共业务就交给了代理角色,实现了业务的分工！\n- 公共业务发生扩展的时候，方便集中管理！\n\n缺点:\n\n- 一个真实角色就会产生一个代理角色；代码量会翻倍,开发效率会变低\n\n\n\n## 10.2、加深理解\n\n代码对应 08-练习demo2\n\n聊聊AOP\n\n<img src=\"C:\\Users\\guosz\\AppData\\Roaming\\Typora\\typora-user-images\\1576484746469.png\" alt=\"1576484746469\" style=\"zoom: 67%;\" />\n\n\n\n## 10.3、动态代理\n\n- 动态代理，和静态代理角色一样\n- 动态代理的类是动态生成的，不是我们直接写好的\n- 动态代理分为两大类：基于接口的动态代理,基于类的动\n  - 基于接口----JDK动态代理【我们在这了使用】\n  - 基于类：cglib\n  - java字节码实现：javasist\n\n需要了解两个类：Proxy:代理 ,InvocationHandler：调用处理程序\n\n\n\n动态代理的好处:\n\n- 可以使真是角色的操作更加纯粹，不用去关注一些公共的业务\n- 公共业务就交给了代理角色,实现了业务的分工！\n- 公共业务发生扩展的时候，方便集中管理！\n- 一个动态代理类代理的是一个接口，一般就是对应的一类业务\n- 一个动态代理类可以代理多个类，只要实现了同一个接口即可\n\n\n\n# 11、AOP\n\n## 11.1、什么是AOP?\n\n ，AOP为Aspect Oriented Programming的缩写，意为：[面向切面编程](https://baike.baidu.com/item/面向切面编程/6016335)，通过[预编译](https://baike.baidu.com/item/预编译/3191547)方式和运行期动态代理实现程序功能的统一维护的一种技术。AOP是[OOP](https://baike.baidu.com/item/OOP)的延续，是软件开发中的一个热点，也是[Spring](https://baike.baidu.com/item/Spring)框架中的一个重要内容，是[函数式编程](https://baike.baidu.com/item/函数式编程/4035031)的一种衍生范型。利用AOP可以对业务逻辑的各个部分进行隔离，从而使得业务逻辑各部分之间的[耦合度](https://baike.baidu.com/item/耦合度/2603938)降低，提高程序的可重用性，同时提高了开发的效率。 \n\n\n\n\n\n## 11.2、AOP在Spring中的作用\n\n==提供声明事务；允许用户自定义切面==\n\n- 横切关注点：跨越应用程序多个模块的方法或功能，即使，与我们业务逻辑无关的，但我们需要关注分部分，就是横切关注点。如日志，安全，缓存，事务等等\n- 切面:（ASPECT）：切面关注点被模块化的特殊对象。即它是一个类。\n- 通知:(Advice)切面必须要完成的工作\n- 目标(Target):被通知对象\n- 代理（Proxy）:向目标对象应用通知之后创建的对象\n- 切入点(PointCut):切面通知执行的“地点”的定义\n- 连接点（JointPoint）：与切入点匹配的执行点\n\n![1576545392198](C:\\Users\\guosz\\AppData\\Roaming\\Typora\\typora-user-images\\1576545392198.png)\n\nSpringAOP中，通过Advice定义横切逻辑，Spring中支持5种类型的Advice：\n\n<img src=\"C:\\Users\\guosz\\AppData\\Roaming\\Typora\\typora-user-images\\1576568456067.png\" alt=\"1576568456067\" style=\"zoom:67%;\" />\n\n即Aop在不改变原代码的情况下，去增加新的功能\n\n\n\n## 11.3、使用Spring实现AOP\n\n【重点】使用AOP织入，需要导入一个依赖包！\n\n```xml\n<dependency>\n            <groupId>org.aspectj</groupId>\n            <artifactId>aspectjweaver</artifactId>\n            <version>1.9.4</version>\n</dependency>\n```\n\n\n\n\n\n方式一：使用Spring的APl接口 【主要SpringAPI接口实现】\n\n方式二：自定义来实现AOP 【主要是切面定义】\n\n方式三:使用注解实现\n\n\n\n# 12、整合Mybatis\n\n步骤:\n\n1.导入相关jar包\n\n- ​	junit		\n\n- myvatis\n- mysql数据库的\n- spring相关的\n- aop织入\n- mybatis-spring【new 】\n\n2.编写配置文件\n\n3.测试\n\n\n\n## 12.1、回忆mybatis\n\n1. 编写实体类\n\n   \n\n2. 编写核心配置文件\n\n3. 编写接口\n\n4. 编写Mapper.xml\n\n5. 测试\n\n\n\n## 12.2、mybatis-spring\n\n\n\n1. 编写数据源配置\n\n   ```xml\n       <!--DataSource :使用Spring的数据源替换mybatis的配置\n       我们这里使用Spring提供的JDBC\n       -->\n       <bean id=\"dataSource\" class=\"org.springframework.jdbc.datasource.DriverManagerDataSource\">\n           <property name=\"driverClassName\" value=\"com.mysql.jdbc.Driver\"/>\n           <property name=\"url\" value=\"jdbc:mysql:///mybatis\"/>\n           <property name=\"username\" value=\"root\"/>\n           <property name=\"password\" value=\"985211\"/>\n       </bean>\n   ```\n\n2. SqlSessionFactory\n\n   ```xml\n      <!--SqlSessionFactory-->\n       <bean id=\"sqlSessionFactory\" class=\"org.mybatis.spring.SqlSessionFactoryBean\">\n           <property name=\"dataSource\" ref=\"dataSource\" />\n           <!--绑定Mybatis配置文件-->\n           <property name=\"configLocation\" value=\"classpath:mybatis-config.xml\"/>\n           <property name=\"mapperLocations\" value=\"classpath:com/Gosion/Mapper/UserMapper.xml\"/>\n       </bean>\n   ```\n\n3. SqlSessionTemplate\n\n   ```xml\n       <!--SqlSessionTemplate 就是我们使用的SqlSession-->\n       <bean id=\"SqlSession\" class=\"org.mybatis.spring.SqlSessionTemplate\">\n           <!--只能使用构造器注入，因为他没有set方法-->\n               <constructor-arg index=\"0\" ref=\"sqlSessionFactory\"/>\n       </bean>\n   ```\n\n4. 需要给接口加实现类\n\n   ```java\n   import com.Gosion.pojo.User;\n   import org.mybatis.spring.SqlSessionTemplate;\n   \n   import java.util.List;\n   \n   public class USerMapperImpl  implements UserMapper{\n       private SqlSessionTemplate sqlSession;\n   \n       public void setSqlSession(SqlSessionTemplate sqlSession) {\n           this.sqlSession = sqlSession;\n       }\n   \n       //我们的所有操作，都使用sqlSession来执行，在原来，现在都是使用SqlSessionTemplate\n       public List<User> selectUser() {\n   \n           UserMapper mapper = sqlSession.getMapper(UserMapper.class);\n           return mapper.selectUser();\n       }\n   }\n   \n   ```\n\n5. 将自己写的实现类，注入到spring中\n\n   ```xml\n      <!---->\n       <bean id=\"userMapper\" class=\"com.Gosion.Mapper.USerMapperImpl\">\n           <property name=\"sqlSession\" ref=\"SqlSession\"/>\n       </bean>\n   ```\n\n6. 测试即可\n\n```java\nimport com.Gosion.Mapper.UserMapper;\nimport com.Gosion.pojo.User;\nimport org.junit.Test;\nimport org.springframework.context.ApplicationContext;\nimport org.springframework.context.support.ClassPathXmlApplicationContext;\n\nimport java.io.IOException;\n\npublic class MyTest {\n    @Test\n    public void test() throws IOException {\n       ApplicationContext context = new ClassPathXmlApplicationContext(\"applicationContext.xml\");\n        UserMapper userMapper = context.getBean(\"userMapper\", UserMapper.class);\n        for (User user : userMapper.selectUser()) {\n            System.out.println(user);\n        }\n    }\n}\n```\n\nspring-dao\n\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<beans xmlns=\"http://www.springframework.org/schema/beans\"\n       xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n       xmlns:aop=\"http://www.springframework.org/schema/aop\"\n       xsi:schemaLocation=\"http://www.springframework.org/schema/beans\n        https://www.springframework.org/schema/beans/spring-beans.xsd\n         http://www.springframework.org/schema/aop\n        https://www.springframework.org/schema/aop/spring-aop.xsd\">\n\n  <!--dataSource-->\n    <bean id=\"dataSource\" class=\"org.springframework.jdbc.datasource.DriverManagerDataSource\">\n        <property name=\"driverClassName\" value=\"com.mysql.jdbc.Driver\"/>\n        <property name=\"url\" value=\"jdbc:mysql://localhost:3306/mybatis?serverTimezone=GMT%2B8&amp;useSSL=false\"/>\n        <property name=\"username\" value=\"root\"/>\n        <property name=\"password\" value=\"985211\"/>\n    </bean>\n    <!--SqlSessionFactory-->\n    <bean id=\"sqlSessionFactory\" class=\"org.mybatis.spring.SqlSessionFactoryBean\">\n        <property name=\"dataSource\" ref=\"dataSource\" />\n\n        <property name=\"configLocation\" value=\"classpath:mybatis-config.xml\"/>\n        <property name=\"mapperLocations\" value=\"classpath:com/Gosion/Mapper/UserMapper.xml\"/>\n    </bean>\n    <bean id=\"SqlSession\" class=\"org.mybatis.spring.SqlSessionTemplate\">\n        <constructor-arg index=\"0\" ref=\"sqlSessionFactory\"/>\n    </bean>\n\n    <bean id=\"userMapper\" class=\"com.Gosion.Mapper.UserMapperImpl\">\n        <property name=\"sqlSession\" ref=\"SqlSession\"/>\n    </bean>\n\n</beans>\n```\n\n==整合需要的jar包==\n\n```xml\n<dependencies>\n    <dependency>\n        <groupId>mysql</groupId>\n        <artifactId>mysql-connector-java</artifactId>\n        <version>8.0.11</version>\n    </dependency>\n\n    <dependency>\n        <groupId>org.mybatis</groupId>\n        <artifactId>mybatis</artifactId>\n        <version>3.5.2</version>\n    </dependency>\n\n    <dependency>\n        <groupId>junit</groupId>\n        <artifactId>junit</artifactId>\n        <version>4.12</version>\n    </dependency>\n\n    <dependency>\n        <groupId>org.mybatis</groupId>\n        <artifactId>mybatis-spring</artifactId>\n        <version>2.0.3</version>\n    </dependency>\n\n    <dependency>\n        <groupId>org.springframework</groupId>\n        <artifactId>spring-webmvc</artifactId>\n        <version>5.2.2.RELEASE</version>\n    </dependency>\n\n    <dependency>\n        <groupId>org.springframework</groupId>\n        <artifactId>spring-jdbc</artifactId>\n        <version>5.2.2.RELEASE</version>\n    </dependency>\n    <dependency>\n        <groupId>org.aspectj</groupId>\n        <artifactId>aspectjweaver</artifactId>\n        <version>1.9.4</version>\n    </dependency>\n    <dependency>\n        <groupId>org.projectlombok</groupId>\n        <artifactId>lombok</artifactId>\n        <version>1.18.10</version>\n        <scope>provided</scope>\n    </dependency>\n    <dependency>\n        <groupId>org.springframework</groupId>\n        <artifactId>spring-context</artifactId>\n        <version>5.2.2.RELEASE</version>\n        <scope>test</scope>\n    </dependency>\n</dependencies>\n```\n\n\n\n# 13、声明式事务\n\n\n\n## 1、回顾事务\n\n- 把一组业务当成一个业务来做；要么都成功，要么都失败！\n- 事务在项目开发中十分重要，涉及到数据的一致性问题，不能马虎！\n- 确保完整性，和一致性；\n\n\n\n事务的ACID原则:\n\n- 原子性\n- 一致性\n- 隔离性\n  - 多个业务可能操作同一个资源，防止数据损坏\n- 持久性\n  - 事务一旦提交，无论系统出什么问题，结果都不会再被影响，被持久化的写到存储器中!\n\n## 2、Spring中的事务管理\n\n- 声明式事务：AOP\n- 编程式事务：需要在代码中，进行事务的管理\n\n思考:\n\n为什么需要事务?\n\n- 如果不配置事务，可能存在数据提交不一致的情况下；\n- 如果我们不在Sping中去声明事务，我门就需要在代码中手动配置事务！\n- 事务在项目的开发中十分重要，设计到一致性和完整性问题，不容马虎\n\n\n\n\n\n\n\n\n\n', NULL, 0, 0, 0, NULL, '2020-12-23', 320, NULL, 104);
INSERT INTO `tb_article` VALUES (31, 20, 'niha', '', 'cfcvdfsvdfv', '', 'cfcvdfsvdfv', NULL, 0, 0, 0, NULL, '2020-12-23', 320, NULL, 105);
INSERT INTO `tb_article` VALUES (32, 22, '分布式', '', 'hello', '', 'hello', NULL, 0, 0, 0, NULL, '2020-12-23', 320, NULL, 105);
INSERT INTO `tb_article` VALUES (33, 22, '负载均衡', '', '负载均衡', '', '负载均衡', NULL, 0, 0, 0, NULL, '2020-12-24', 320, NULL, 101);
INSERT INTO `tb_article` VALUES (34, 22, '春风吹', '', '吃饭吃饭', '', '吃饭吃饭', NULL, 0, 0, 0, NULL, '2020-12-24', 320, NULL, 102);
INSERT INTO `tb_article` VALUES (35, 22, '你kin', '', '你擦', '', '你擦', NULL, 0, 0, 0, NULL, '2020-12-24', 320, NULL, 128);
INSERT INTO `tb_article` VALUES (37, 22, '得我', '', '成都市', '充分的', '成都市', NULL, 0, 0, 0, NULL, '2020-12-24', 320, NULL, 111);
INSERT INTO `tb_article` VALUES (55, 24, '通知', '', '通知', '', '通知', NULL, 0, 0, 0, NULL, '2020-12-29', 320, '2020-12-29', 0);
INSERT INTO `tb_article` VALUES (56, 20, 'Linux', 'http://localhost:8081/cms/upload/f0790875-d59a-45c4-9f52-e7e4b00e540a.jpg', 'vfd', '', 'vfd', NULL, 0, 0, 0, NULL, '2021-01-01', 320, '2021-01-01', 0);

-- ----------------------------
-- Table structure for tb_article_attachment
-- ----------------------------
DROP TABLE IF EXISTS `tb_article_attachment`;
CREATE TABLE `tb_article_attachment`  (
  `id` int(11) NOT NULL AUTO_INCREMENT COMMENT 'ID',
  `article_id` int(11) NULL DEFAULT NULL COMMENT '文章ID',
  `url` varchar(100) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NULL DEFAULT NULL COMMENT '路径',
  PRIMARY KEY (`id`) USING BTREE
) ENGINE = InnoDB CHARACTER SET = utf8mb4 COLLATE = utf8mb4_0900_ai_ci COMMENT = '文章附件' ROW_FORMAT = Dynamic;

-- ----------------------------
-- Records of tb_article_attachment
-- ----------------------------
INSERT INTO `tb_article_attachment` VALUES (1, 5, 'http://localhost:8081/cms/upload/fc9891d1-5496-41c5-a218-c7fa70826950.jpg');
INSERT INTO `tb_article_attachment` VALUES (2, 5, 'http://localhost:8081/cms/upload/65d115df-309c-41ea-a84c-7b3cf5e80095.jpg');
INSERT INTO `tb_article_attachment` VALUES (3, 6, 'http://localhost:8081/cms/upload/6c337640-cc50-4d6a-bfb2-46452cbeda9f.jpg');

-- ----------------------------
-- Table structure for tb_article_tag
-- ----------------------------
DROP TABLE IF EXISTS `tb_article_tag`;
CREATE TABLE `tb_article_tag`  (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `article_id` int(11) NULL DEFAULT NULL,
  `tag_id` int(11) NULL DEFAULT NULL,
  PRIMARY KEY (`id`) USING BTREE
) ENGINE = InnoDB AUTO_INCREMENT = 49 CHARACTER SET = utf8mb4 COLLATE = utf8mb4_0900_ai_ci COMMENT = '文章标签' ROW_FORMAT = Dynamic;

-- ----------------------------
-- Records of tb_article_tag
-- ----------------------------
INSERT INTO `tb_article_tag` VALUES (32, 22, 5);
INSERT INTO `tb_article_tag` VALUES (33, 23, 5);
INSERT INTO `tb_article_tag` VALUES (34, 24, 5);
INSERT INTO `tb_article_tag` VALUES (35, 25, 5);
INSERT INTO `tb_article_tag` VALUES (36, 26, 5);
INSERT INTO `tb_article_tag` VALUES (37, 27, 5);
INSERT INTO `tb_article_tag` VALUES (40, 31, 5);
INSERT INTO `tb_article_tag` VALUES (41, 32, 4);
INSERT INTO `tb_article_tag` VALUES (48, 44, 4);

-- ----------------------------
-- Table structure for tb_channel
-- ----------------------------
DROP TABLE IF EXISTS `tb_channel`;
CREATE TABLE `tb_channel`  (
  `id` int(11) NOT NULL AUTO_INCREMENT COMMENT 'ID',
  `name` varchar(100) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NULL DEFAULT NULL COMMENT '名称',
  `parent_id` int(11) NULL DEFAULT NULL COMMENT '上级栏目',
  `channel_img` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NULL DEFAULT NULL COMMENT '栏目图片',
  `summary` varchar(200) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NULL DEFAULT NULL COMMENT '摘要',
  `single` char(1) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NULL DEFAULT NULL COMMENT '是否单页 .Y为单页，Null为不单页',
  `url` varchar(100) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NULL DEFAULT NULL COMMENT '外链URL',
  `seo_title` varchar(100) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NULL DEFAULT NULL COMMENT 'SEO标题',
  `seo_keyword` varchar(200) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NULL DEFAULT NULL COMMENT 'SEO关键字',
  `seo_description` varchar(200) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NULL DEFAULT NULL COMMENT 'SEO描述',
  `content` text CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NULL COMMENT '正文',
  `create_user` int(11) NULL DEFAULT NULL COMMENT '创建人',
  `create_date` date NULL DEFAULT NULL COMMENT '创建时间',
  `pos` char(1) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NULL DEFAULT NULL COMMENT '位置',
  PRIMARY KEY (`id`) USING BTREE
) ENGINE = InnoDB CHARACTER SET = utf8mb4 COLLATE = utf8mb4_0900_ai_ci COMMENT = '栏目' ROW_FORMAT = Dynamic;

-- ----------------------------
-- Records of tb_channel
-- ----------------------------
INSERT INTO `tb_channel` VALUES (19, 'Java', 0, '', '', 'Y', '', '', '', '', '# SpringSecurity\n\n\n\n## 第一章、Spring security基础篇\n\n### SpringSecurity 的核心功能\n\n​	\n\n- Authentication :身份认证，用户登录的验证（你是谁？）\n- Authorization：访问授权，授权资源的访问权限（你能干什么？）\n- 安全防护，防止跨站的请求，session攻击等\n\n\n\nshiro和springsecurity对比：\n\n- shiro入门容易\n\n- spring security 相对门槛高，但已经有所改善\n- shiro属于apache社区\n- spring secutity 是Spring社区的亲儿子\n\n\n\n\n\n### HttpBasic认证\n\nHttpBasic认证模式是Spring Security实现登录认证最简单的一种方式\n\n\n\n防君子不妨小人\n\n\n\n### PasswordEncoder\n\nHash算法\n\n- 单向算法\n- hash（密码）不可逆\n\n\n\n加密后 $2a 表示 BCrypt 算法版本\n\n$10 //表示算法强度\n\n$0v7A2TRdj1dw7kWOJJD/k.lA4QwPhMg1Ky1XbrgFyt1Wu/7ZFQkhy //随机生成的盐值\n\n\n\n### FormLogin\n\n- formLogin 登录认证不写Controller方法\n- 传统登录认证 ，UsernamePasswordAuthenticationFilter\n- UsernamePassAuthentionFilter过滤器是默认集成的，我们只需要针对它进行配置。\n\n#### 配置三要素\n\n- 登录认证逻辑-登录URL、如何接受登录参数、登录成功后逻辑（静态）\n- 资源访问控制-决定什么用户、什么角色可以访问什么资源（动态-数据库）\n- 用户角色权限-配置某个用户拥有什么角色、拥有什么权限（动态-数据库）\n\n\n\n配置\n\n```java\nprotected void configure(HttpSecurity http) throws Exception {\n//        http.httpBasic()//开启httpBasic认证\n//                .and()\n//                .authorizeRequests()\n//                .anyRequest()\n//                .authenticated();//所有请求都需要登录认证才能访问\n        http.csrf().disable().formLogin()\n                .loginPage(\"/login.html\")//一旦用户的请求没有权限就会跳转到这个页面\n                .loginProcessingUrl(\"login\")//登录表单form中的action的地址\n                .usernameParameter(\"username\")//在登录表单form中用户名输入框input中的username\n                .passwordParameter(\"password\")\n                .defaultSuccessUrl(\"/\")//登录认证成功后默认要跳转的路径\n                .and()\n                .authorizeRequests()\n                .antMatchers(\"login.html\",\"login\").permitAll()//不需要通过登录验证就可以被访问的资源网站\n                .antMatchers(\"/\",\"biz1\",\"biz2\")//资源路径匹配\n                    .hasAnyAuthority(\"ROLE_user\",\"ROLE_admin\")  //user和admin角色都可以访问\n                .antMatchers(\"/syslog\",\"/sysuer\")//资源路径匹配\n                .hasRole(\"admin\");//admin角色可以访问\n```\n\n角色是一种特殊的权限\n\n- HasAnyAuthority(\"ROLE_admin\"，\"ROLE_admin\") 等价于  hasAnyRole(\"user\",\"admin\")\n\n\n\n\n\n### 登录验证流程\n\n![image-20201207144642634](C:\\Users\\guosz\\OneDrive\\桌面\\image-20201207144642634.png)\n\n\n\n### 自定义登录验证结果处理\n\n- 不同的人登录之后，看到不同的首页（即向不同页面跳转）\n- 前后端分离的应用，期望响应结果是json，而不是html页面\n\n\n\n登录成功的自定义结果处理接口：AuthentionSuccessHandler\n\n1. ```JAVA\n   import com.fasterxml.jackson.databind.ObjectMapper;\n   import com.zimug.commons.exception.AjaxResponse;\n   import org.springframework.beans.factory.annotation.Value;\n   import org.springframework.security.core.Authentication;\n   import org.springframework.security.web.authentication.SavedRequestAwareAuthenticationSuccessHandler;\n   import org.springframework.stereotype.Component;\n   \n   import javax.servlet.ServletException;\n   import javax.servlet.http.HttpServletRequest;\n   import javax.servlet.http.HttpServletResponse;\n   import javax.validation.Valid;\n   import java.io.IOException;\n   \n   /**\n    * 配置登录成功后的自定义结果处理接口\n    */\n   @Component\n   public class MyAuthenticationSuccessHandler\n           extends SavedRequestAwareAuthenticationSuccessHandler {\n       //SavedRequestAwareAuthenticationSuccessHandler  它有自动记住上一次请求路径地址的功能\n   \n       @Value(\"${spring.security.logintype}\")\n       private String loginType;\n   \n       private static ObjectMapper objectMapper=new ObjectMapper();\n   \n       @Override\n       public void onAuthenticationSuccess(HttpServletRequest request,\n                                           HttpServletResponse response,\n                                           Authentication authentication)\n               throws ServletException, IOException {\n           if (loginType.equalsIgnoreCase(\"JSON\")){\n               response.setContentType(\"application/json;charset=UTF-8\");\n               response.getWriter().write(objectMapper.writeValueAsString(AjaxResponse.success()));\n           }else {\n               //会帮我们跳转到上一次请求的页面上\n               super.onAuthenticationSuccess(request,response,authentication);\n           }\n       }\n   }\n   ```\n\n2. ```java\n   .successHandler(myAuthenticationSuccessHandler)//登录成功使用自定义路径\n   .failureHandler(myAuthenticationFailureHandler)//登录失败跳转自定义路径\n   ```\n\n3. 请求数据\n\n   ```html\n     $.ajax({\n               type: \"POST\",\n               url: \"/login\",\n               data:{\n                   \"username\":username, //这里的参数名称要和Spring Security配置一致\n                   \"password\":password\n               },\n               success: function (json) {\n                   console.log(json);\n                   if (json.isok){\n                       location.href=\'/\' //index.html\n                   }else {\n                       console.log(json.message)\n                       alert(json.message);\n                       location.href=\'/login.html\'\n                   }\n               },\n               error:function (e) {\n   \n               }\n           })\n       }\n   ```\n\n   \n\n登录失败的自定义结果处理接口：AuthenticationfailureHandler\n\n1. \n\n2. ```\n   import com.fasterxml.jackson.databind.ObjectMapper;\n   import com.zimug.commons.exception.AjaxResponse;\n   import com.zimug.commons.exception.CustomException;\n   import com.zimug.commons.exception.CustomExceptionType;\n   import org.springframework.beans.factory.annotation.Value;\n   import org.springframework.security.core.AuthenticationException;\n   import org.springframework.security.web.authentication.SimpleUrlAuthenticationFailureHandler;\n   import org.springframework.stereotype.Component;\n   \n   import javax.servlet.ServletException;\n   import javax.servlet.http.HttpServletRequest;\n   import javax.servlet.http.HttpServletResponse;\n   import java.io.IOException;\n   \n   /**\n    * 登录错误后的处理\n    */\n   @Component\n   public class MyAuthenticationFailureHandler extends SimpleUrlAuthenticationFailureHandler {\n   \n       @Value(\"spring.security.logintype\")\n       private String logintype;\n   \n       private static ObjectMapper objectMapper=new ObjectMapper();\n       @Override\n       public void onAuthenticationFailure(HttpServletRequest request,\n                                           HttpServletResponse response,\n                                           AuthenticationException exception)\n               throws IOException, ServletException {\n   \n           if (logintype.equalsIgnoreCase(\"JSON\")){\n               response.setContentType(\"application/json;charset=UTF-8\");\n               response.getWriter().write(objectMapper.writeValueAsString(AjaxResponse.userInputError(\"您检查您的用户名和密码输入是否正确\")));\n           }else {\n               response.setContentType(\"text/html;charset=UTF-8\");\n               super.onAuthenticationFailure(request,response,exception);\n           }\n   \n       }\n   }\n   ```\n\n3. ```java\n   import com.fasterxml.jackson.databind.ObjectMapper;\n   import com.zimug.commons.exception.AjaxResponse;\n   import com.zimug.commons.exception.CustomException;\n   import com.zimug.commons.exception.CustomExceptionType;\n   import org.springframework.beans.factory.annotation.Value;\n   import org.springframework.security.core.AuthenticationException;\n   import org.springframework.security.web.authentication.SimpleUrlAuthenticationFailureHandler;\n   import org.springframework.stereotype.Component;\n   \n   import javax.servlet.ServletException;\n   import javax.servlet.http.HttpServletRequest;\n   import javax.servlet.http.HttpServletResponse;\n   import java.io.IOException;\n   \n   /**\n    * 登录错误后的处理\n    */\n   @Component\n   public class MyAuthenticationFailureHandler extends SimpleUrlAuthenticationFailureHandler {\n   \n       @Value(\"spring.security.logintype\")\n       private String logintype;\n   \n       private static ObjectMapper objectMapper=new ObjectMapper();\n       @Override\n       public void onAuthenticationFailure(HttpServletRequest request,\n                                           HttpServletResponse response,\n                                           AuthenticationException exception)\n               throws IOException, ServletException {\n   \n           if (logintype.equalsIgnoreCase(\"JSON\")){\n               response.setContentType(\"application/json;charset=UTF-8\");\n               response.getWriter().write(objectMapper.writeValueAsString(AjaxResponse.userInputError(\"您检查您的用户名和密码输入是否正确\")));\n           }else {\n               response.setContentType(\"text/html;charset=UTF-8\");\n               super.onAuthenticationFailure(request,response,exception);\n           }\n   \n       }\n   }\n   \n   ```\n\n4. ```java\n   .successHandler(myAuthenticationSuccessHandler)//登录成功使用自定义路径\n   .failureHandler(myAuthenticationFailureHandler)//登录失败跳转自定义路径\n   ```\n\n\n\n\n\n### SpringSecutity session创建策略\n\n\n\n- always :如果当前请求没有对应的session存在，创建一个session\n- ifRequired（默认）：在需要使用到session时才创建session\n- never：SpringSecurity 将永远不会主动创建session，但是如果session在当前应用中已经存在，它将使用该session\n- stateless：Spring Security 不会创建或使用任何session。适合于接口型的无状态应用（前后端分离），该方式节省内存资源。\n\n\n\n一般不需要修改，如果非要修改的话，就在Secutity下的Config http参数的配置。\n\n```java\n.and()\n                .sessionManagement()\n                .sessionCreationPolicy(SessionCreationPolicy.ALWAYS); //可以设置多个\n```\n\n![image-20201207183925758](C:\\Users\\guosz\\OneDrive\\桌面\\image-20201207183925758.png)\n\n\n\n#### 会话超时配置\n\n- server.servlet.timout=15m\n- spring.session.timout=15m\n\n\n\n##### 会话超时跳转地址\n\n```java\n.and().sessionManagement()\n                .invalidSessionUrl(\"/invalidSession.html\");\n```\n\n\n\n#### session保护\n\n- migrationSession保护方式（默认）。即对于同一个SESSION用户，每次登陆验证将创建一个新的HTTP session，旧的session将无效，将旧的session属性复制到新的session上面。\n\n  \n\n- 设置为 \"none\"时，原始会话不会无效\n\n  \n\n- 设置  \"newSession\"后，将创建一个干净的会话，而不会复制旧会话中的任何属性\n\n```java\n.and().sessionManagement()\n                .invalidSessionUrl(\"/invalidSession.html\")\n                .sessionFixation().migrateSession();//session保护配置\n```\n\n\n\n#### Cookie的安全\n\n- httpOnly:如果为true，则浏览器脚本将无法访问cookie\n- secure :如果为true，则仅通过HTTPS连接发送cookie，HTTP无法携带cookie。\n\n\n\n### 同账号多段登录被迫下线\n\n\n\nsession安全管理\n\n- spring Security session 创建策略\n- 会话超时配置及自定义处理\n- session 固定保护\n- Cookie的安全配置\n\n#### 限制最大登录用户数量\n\n```java\n.sessionManagement()\n    .maximumSesions(1)\n    .maxSessionPreventLogin(false)\n    .expiredSessionStrategy(new CustomExpiredSessionStrategy())\n```\n\ntrue 表示 已经登录就不允许再次登录\n\nfalse 表示允许再次登录，但是之前的登录账号不会被踢下线\n\n\n\n演示\n\n```java\n.and().sessionManagement()\n                .invalidSessionUrl(\"/invalidSession.html\")\n                .sessionFixation().migrateSession()\n                .maximumSessions(1)\n                .maxSessionsPreventsLogin(false)\n                .expiredSessionStrategy(new CustomExpiredSessionStrategy()); //自定义了跳转的路径\n```\n\n```java\nimport org.springframework.security.web.DefaultRedirectStrategy;\nimport org.springframework.security.web.RedirectStrategy;\nimport org.springframework.security.web.session.SessionInformationExpiredEvent;\nimport org.springframework.security.web.session.SessionInformationExpiredStrategy;\n\nimport javax.servlet.ServletException;\nimport java.io.IOException;\n\npublic class CustomExpiredSessionStrategy implements SessionInformationExpiredStrategy {\n\n    //页面跳转的处理逻辑\n    private RedirectStrategy redirectStrategy =new DefaultRedirectStrategy();\n\n    @Override\n    public void onExpiredSessionDetected(SessionInformationExpiredEvent event)\n            throws IOException, ServletException {\n\n        redirectStrategy.sendRedirect(event.getRequest(),event.getResponse(),\"/logout\");\n\n    }\n}\n\n```\n\n![image-20201207195143670](C:\\Users\\guosz\\AppData\\Roaming\\Typora\\typora-user-images\\image-20201207195143670.png)\n\n\n\n登录之后一开始登录的就会被踢掉。\n\n\n\n前后端分离，需要返回json数据\n\n```java\n    private ObjectMapper objectMapper=new ObjectMapper();\n\n    @Override\n    public void onExpiredSessionDetected(SessionInformationExpiredEvent event)\n            throws IOException, ServletException {\n//        redirectStrategy.sendRedirect(event.getRequest(),event.getResponse(),\"/logout\");\n\n        HashMap<String, Object> map = new HashMap<>();\n        map.put(\"code\",403);\n        map.put(\"msg\",\"您的登录已经超时或者在应一台机器登录，您被迫下线\"\n                +event.getSessionInformation().getLastRequest());\n        String json=objectMapper.writeValueAsString(map);\n        event.getResponse().setContentType(\"application/json;charset=UTF-8\");\n        event.getResponse().getWriter().write(json);\n    }\n```\n\n测试完成\n\n<img src=\"C:\\Users\\guosz\\AppData\\Roaming\\Typora\\typora-user-images\\image-20201207200241534.png\" alt=\"image-20201207200241534\" style=\"zoom: 50%;\" />\n\n\n\n## 第二章、认证授权鉴权功能深入\n\n\n\nRole-Based Access Control\n\n- 用户：系统接口及能访问的操作者\n- 权限：能够访问某接口或者做某操作的授权资格\n- 角色：具有一类相同操作权限的用户的总称  \n\n\n\n### 动态加载用户角色权限\n\n动态加载\n\n- UserDetails 接口表达你是谁？你有什么角色权限？\n- UserDetailsService接口 表达的是如何动态加载UserDetails数据\n\n\n\nUserdetails接口\n\n<img src=\"C:\\Users\\guosz\\OneDrive\\桌面\\image-20201208103348752.png\" alt=\"image-20201208103348752\" style=\"zoom:50%;\" />\n\n\n\n\n\nUserDetailsService接口\n\n\n\n<img src=\"C:\\Users\\guosz\\OneDrive\\桌面\\image-20201208123425844.png\" alt=\"image-20201208123425844\" style=\"zoom:50%;\" />\n\nservice类\n\n```java\n    @Autowired\n    private MyUserDetailsServiceMapper myUserDetailsServiceMapper;\n\n\n    @Override\n    public UserDetails loadUserByUsername(String username) throws UsernameNotFoundException {\n\n        //用户基础加载\n        MyUserDetails myUserDetails = myUserDetailsServiceMapper.findByUserName(username);\n\n        if (myUserDetails==null){\n            throw new UsernameNotFoundException(\"用户名不存在\");\n        }\n        System.out.println(\"打印一下查询的账号和密码\"+myUserDetails.toString());\n        //用户的角色列表加载\n        List<String> roleCodes = myUserDetailsServiceMapper.findRoleByUserName(username);\n\n\n        //根据角色列表加载当前具有的权限\n        List<String> authorityByRoleCodes = myUserDetailsServiceMapper.findAuthorityByRoleCodes(roleCodes);\n        System.out.println(\"ROleCode==》\"+authorityByRoleCodes);\n       roleCodes= roleCodes.stream()\n                .map(rc-> \"ROLE_\"+rc)\n                .collect(Collectors.toList());\n\n       authorityByRoleCodes.addAll(roleCodes);\n       myUserDetails.setAuthorities(AuthorityUtils.commaSeparatedStringToAuthorityList(\n               String.join(\",\",authorityByRoleCodes)\n       ));\n\n       myUserDetails.setEnable(true);\n       return myUserDetails;\n    }\n```\n\nmapper接口\n\n```java\npublic interface MyUserDetailsServiceMapper {\n\n    //根据userId查询用户信息\n    @Select(\"SELECT username,password,enabled\\n\"+\n            \"FROM sys_user u\\n\"+\n            \"WHERE u.username =#{userId}\"\n    )\n    MyUserDetails findByUserName(@Param(\"userId\") String userId);\n\n\n    @Select(\"SELECT role_code\\n\"+\n        \"FROM sys_role r\\n\"+\n            \"LEFT JOIN sys_user_role ur ON r.id=ur.role_id\\n\"+\n            \"LEFT JOIN sys_user u ON u.id=ur.user_id\\n\"+\n            \"WHERE u.username =#{userId}\"\n    )\n    List<String> findRoleByUserName(@Param(\"userId\") String userId);\n\n\n    //根据用户角色查询用户权限\n    //根据用户角色查询用户权限\n    @Select({\n            \"<script>\",\n            \"SELECT url \" ,\n            \"FROM sys_menu m \" ,\n            \"LEFT JOIN sys_role_menu rm ON m.id = rm.menu_id \" ,\n            \"LEFT JOIN sys_role r ON r.id = rm.role_id \",\n            \"WHERE r.role_code IN \",\n            \"<foreach collection=\'roleCodes\' item=\'roleCode\' open=\'(\' separator=\',\' close=\')\'>\",\n            \"#{roleCode}\",\n            \"</foreach>\",\n            \"</script>\"\n    })\n    List<String> findAuthorityByRoleCodes(@Param(\"roleCodes\") List<String> roleCodes);\n}\n\n```\n\n\n\n### 动态加载资源鉴权规则\n\n配置一个Service类\n\n```java\nimport org.springframework.security.core.Authentication;\nimport org.springframework.security.core.authority.SimpleGrantedAuthority;\nimport org.springframework.security.core.userdetails.UserDetails;\nimport org.springframework.stereotype.Component;\nimport org.springframework.stereotype.Service;\n\nimport javax.servlet.http.HttpServletRequest;\n\n@Component(\"rbacService\")\npublic class MyRBACService {\n\n    public boolean hasPermission(HttpServletRequest request, Authentication authentication){\n        Object principal = authentication.getPrincipal();\n\n        if (principal instanceof UserDetails){//判断下是不是UserDetails类型\n            UserDetails userDetails=((UserDetails)principal);\n\n            //\"/syslog\"\n            //本次要访问的资源\n            SimpleGrantedAuthority simpleGrantedAuthority =\n                    new SimpleGrantedAuthority(request.getRequestURI());\n\n            return userDetails.getAuthorities().contains(simpleGrantedAuthority);\n        }\n\n        return false;\n    }\n}\n```\n\n在security配置中写入\n\n```java\n.anyRequest().access(\"@rbacService.hasPermission(request,authentication)\")\n```\n\n<img src=\"C:\\Users\\guosz\\OneDrive\\桌面\\image-20201208165838257.png\" alt=\"image-20201208165838257\" style=\"zoom:50%;\" />\n\n\n\n### SPEL权限表达式\n\n\n\n<img src=\"C:\\Users\\guosz\\AppData\\Roaming\\Typora\\typora-user-images\\image-20201208191906265.png\" alt=\"image-20201208191906265\" style=\"zoom:67%;\" />\n\n\n\n### RememberMe记住密码\n\n最简单实现\n\n​	后端配置\n\n```java\nhttp.rememberMe(); //实现记住我自动登录配置，核心的代码只有这一行\n```\n\n前端实现\n\n```java\n<label><input type=\"checkbox\" name=\"remember-me\"/>记住密码</label>\n```\n\n\n\n还有一些基本的配置\n\n```java\nhttp.rememberMe()\n                .rememberMeParameter(\"rememberMe-me-new\")//传参的名称\n                .rememberMeCookieName(\"remember-me-cookie\")//cookie名称\n                .tokenValiditySeconds(2*24*60*60)//令牌生成到过期的时间\n```\n\nRemenmberMeToken =username, expiryTime,signatureValue 的Base64加密\n\nsignatureValue = username、exiprationTime和password和一个预定义的key，并将和他们经过MD5进行签名。\n\n\n\n\n\n### 用户退出\n\n```java\nhttp..logout()//退出登录\n```\n\n\n\nlogout的默认行为\n\n1. 当前session失效，即logout的核心需求。session失效就是访问权限的回收\n2. 删除当前用户的remember-me 记住我功能信息\n3. clear 清除当前的securityContext\n4. 重定向到登录页面，loginPage配置项指定的页面\n\n\n\n\n\n配置信息：\n\n```java\n.logout()//退出登录\n                    .logoutUrl(\"sigout\")//默认退出的路径\n                    .logoutSuccessUrl(\"/afcdj.html\")//退出后重定向指定的页面\n                    .deleteCookies(\"JSESSIONID\")//删除cookie 的名字 。可以写多个\n```\n\n\n\nLoginSuccessHandler\n\n- 编辑实现个性化退出功能\n- `注意logoutSuccessUrl不要与logoutSuccessHandler 一起使用，否则logoutSuccessHandler将失效。`\n\n注入我们写好的配置类\n\n```java\nlogout().logoutSuccessHandler(myLogoutSuccessHandler)\n```\n\n```java\nimport javax.servlet.ServletException;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\nimport java.io.IOException;\n@Component\npublic class MyLogoutSuccessHandler implements LogoutSuccessHandler {\n    @Override\n    public void onLogoutSuccess(HttpServletRequest httpServletRequest,\n                                HttpServletResponse httpServletResponse,\n                                Authentication authentication)\n            throws IOException, ServletException {\n        //写一些业务逻辑，比如登录时间的统计。\n\n        httpServletResponse.sendRedirect(\"/login.html\");\n\n    }\n}\n```\n\n### 基于Session图片验证码实现\n\n\n\n验证码工具类库\n\n- 生成验证码文字或其他用于校验的数据形式（即谜底）\n- 生成验证码前端实现图片或拼图等（即谜面）\n- 用于校验用户输入与谜底的校验方法（如果是纯文字，就自己比对以下就可以。如果是基于物理图形拖拽，旋转等方式，需要专用的校验方法）\n\n\n\n#### 集成实现\n\n1. 新建一个properties\n\n   ```properties\n   kaptcha.border=no\n   kaptcha.border.color=105,179,90\n   kaptcha.image.width=100\n   kaptcha.image.height=45\n   kaptcha.session.key=code\n   kaptcha.textproducer.font.color=blue\n   kaptcha.textproducer.font.size=35\n   kaptcha.textproducer.char.length=4\n   kaptcha.textproducer.font.name=宋体,楷体,微软雅黑\n   \n   ```\n\n2. 配置文件集成到配置类中\n\n   ```java\n   import com.google.code.kaptcha.impl.DefaultKaptcha;\n   import com.google.code.kaptcha.util.Config;\n   import org.springframework.beans.factory.annotation.Value;\n   import org.springframework.context.annotation.Bean;\n   import org.springframework.context.annotation.PropertySource;\n   import org.springframework.stereotype.Component;\n   \n   import java.util.Properties;\n   @Component\n   @PropertySource(value = {\"classpath:kaptcha.properties\"})\n   public class CaptchaConfig {\n       @Value(\"${kaptcha.border}\")\n       private String border;\n       @Value(\"${kaptcha.border.color}\")\n       private String borderColor;\n       @Value(\"${kaptcha.textproducer.font.color}\")\n       private String fontColor;\n       @Value(\"${kaptcha.image.width}\")\n       private String imageWidth;\n       @Value(\"${kaptcha.image.height}\")\n       private String imageHeight;\n       @Value(\"${kaptcha.session.key}\")\n       private String sessionKey;\n       @Value(\"${kaptcha.textproducer.char.length}\")\n       private String charLength;\n       @Value(\"${kaptcha.textproducer.font.name}\")\n       private String fontNames;\n       @Value(\"${kaptcha.textproducer.font.size}\")\n       private String fontSize;\n   \n       @Bean(name = \"captchaProducer\")\n       public DefaultKaptcha getKaptchaBean(){\n           DefaultKaptcha defaultKaptcha = new DefaultKaptcha();\n   \n           Properties properties=new Properties();\n           properties.setProperty(\"kaptcha.border\",border);\n           properties.setProperty(\"kaptcha.border.color\",borderColor);\n           properties.setProperty(\"kaptcha.textproducer.font.color\",fontColor);\n           properties.setProperty(\"kaptcha.image.width\",imageWidth);\n           properties.setProperty(\"kaptcha.image.height\",imageHeight);\n           properties.setProperty(\"kaptcha.session.key\",sessionKey);\n           properties.setProperty(\"kaptcha.textproducer.char.length\",charLength);\n           properties.setProperty(\"kaptcha.textproducer.font.name\",fontNames);\n           properties.setProperty(\"kaptcha.textproducer.font.size\",fontSize);\n   \n           defaultKaptcha.setConfig(new Config(properties));\n           return defaultKaptcha;\n       }\n   }\n   ```\n\n   \n\n3. 封装一个实体类\n\n   ```java\n   import java.time.LocalDateTime;\n   \n   public class CaptchaImageVO {\n   \n       private String code;\n       private LocalDateTime expireTime;\n   \n       public CaptchaImageVO(String code, int expireAfterSeconds) {\n           this.code = code;\n           this.expireTime = LocalDateTime.now().plusSeconds(expireAfterSeconds);\n       }\n   \n       //判断验证码有没有过期\n       public boolean isExpired(){\n           return LocalDateTime.now().isAfter(expireTime);\n       }\n   }\n   \n   ```\n\n   \n\n4. 验证码生成Controller\n\n   ```java\n   import com.google.code.kaptcha.impl.DefaultKaptcha;\n   import com.zimug.courses.security.basic.auth.imagecode.CaptchaImageVO;\n   import org.springframework.web.bind.annotation.RequestMapping;\n   import org.springframework.web.bind.annotation.RequestMethod;\n   import org.springframework.web.bind.annotation.RestController;\n   \n   import javax.annotation.Resource;\n   import javax.imageio.ImageIO;\n   import javax.servlet.ServletOutputStream;\n   import javax.servlet.http.HttpServletResponse;\n   import javax.servlet.http.HttpSession;\n   import java.awt.image.BufferedImage;\n   import java.io.IOException;\n   \n   @RestController\n   public class CaptchaController {\n   \n       @Resource\n       private DefaultKaptcha captchaProducer;\n   \n       @RequestMapping(value = \"/kaptcha\",method = RequestMethod.GET)\n       public void kaptcha(HttpSession session, HttpServletResponse response) throws IOException {\n           response.setDateHeader(\"Expires\",0);\n           response.setHeader(\"Cache-Control\",\"no-store, no-cache, must-revalidate\");\n           response.addHeader(\"Cache-Control\",\"post-check=0,pre-check=0\");\n           response.setHeader(\"Pragma\",\"no-cache\");\n           response.setContentType(\"image/jpeg\");\n   \n   \n           String text = captchaProducer.createText();\n           session.setAttribute(\"captcha_key\",\n                   new CaptchaImageVO(text,2*60));//两分钟\n   \n         try (ServletOutputStream out= response.getOutputStream()){\n             BufferedImage bufferedImage= captchaProducer.createImage(text);\n             ImageIO.write(bufferedImage,\"jpg\",out);\n             out.flush();\n         }\n   \n   \n       }\n   }\n   ```\n\n   \n\n5. 前端配置 img\n\n   ```html\n   <!DOCTYPE html >\n   <html lang=\"en\" xmlns:th=\"http://www.thymeleaf.org\">\n   <head>\n       <meta charset=\"UTF-8\">\n       <title>首页</title>\n   \n       <script src=\"js/jquery-3.5.1.min.js\"></script>\n   </head>\n   <body>\n   <h1>字母哥业务系统登录</h1>\n   <form action=\"/login\" method=\"post\">\n       <span>用户名称</span><input type=\"text\" id=\"username\" name=\"username\" /> <br>\n       <span>用户密码</span><input type=\"password\" id=\"password\" name=\"password\" /> <br>\n       <span>验证码</span><input type=\"text\" id=\"captchaCode\" name=\"captchaCode\" />\n       <img src=\"/kaptcha\" id=\"kaptcha\" width=\"110px\" height=\"40px\"/><br>\n       <input type=\"button\" onclick=\"login()\" value=\"登陆\">\n       <label><input type=\"checkbox\" name=\"remember-me\" id=\"remember-me\">记住密码</label>\n   </form>\n   \n   \n   <script type=\"text/javascript\">\n   \n       window.onload=function (ev) {\n           var kaptchaImg = document.getElementById(\"kaptcha\");\n   \n           kaptchaImg.onclick=function (evl) {\n               kaptchaImg.src=\"/kaptcha?\"+Math.floor(Math.random()*100)\n           }\n       };\n       function login() {\n           var username=$(\"#username\").val();\n           var password=$(\"#password\").val();\n           var rememberMe=$(\"#remember-me\").is(\":checked\");\n   \n           if (username=== \"\"||password===\"\"){\n               alert(\'用户名或密码不能为空\');\n               return ;\n           }\n   \n           $.ajax({\n               type: \"POST\",\n               url: \"/login\",\n               data:{\n                   \"username\":username, //这里的参数名称要和Spring Security配置一致\n                   \"password\":password,\n                   \"remember-me\":rememberMe\n               },\n               success: function (json) {\n                   console.log(json);\n                   if (json.isok){\n                       location.href=\'/\' //index.html\n                   }else {\n                       console.log(json.message)\n                       alert(json.message);\n                       location.href=\'/login.html\'\n                   }\n               },\n               error:function (e) {\n   \n               }\n           })\n       }\n   </script>\n   </body>\n   </html>\n   ```\n\n   \n\n6. 访问页面查看\n\n   <img src=\"C:\\Users\\guosz\\OneDrive\\桌面\\image-20201209110052138.png\" alt=\"image-20201209110052138\" style=\"zoom: 50%;\" />\n\n\n\n#### 验证码校验\n\n\n\n图片验证码校验过滤器\n\n1. 编写自定义图片验证码过滤器CaptchaCodeFilter,过滤中拦截登录请求\n2. 过滤器中从session获取验证码文字与用户输入比对，比对通过执行其他过滤器链\n3. 比对不通过，抛出SessionAuthenticationException异常交给AuthenticationFailureHandler处理器\n4. 最后将CaptchaCodeFilter放在UsernamePasswordAuthenticationFilter 过滤器前执行。\n\n写一个CaptchaCodeFilter类进行验证\n\n```java\nimport com.zimug.courses.security.basic.config.MyAuthenticationFailureHandler;\nimport com.zimug.courses.security.basic.utils.MyContants;\nimport org.springframework.security.core.AuthenticationException;\nimport org.springframework.security.web.authentication.session.SessionAuthenticationException;\nimport org.springframework.stereotype.Component;\nimport org.springframework.web.bind.ServletRequestBindingException;\nimport org.springframework.web.bind.ServletRequestUtils;\nimport org.springframework.web.context.request.ServletWebRequest;\nimport org.springframework.web.filter.OncePerRequestFilter;\n\nimport javax.annotation.Resource;\n\nimport javax.servlet.FilterChain;\nimport org.apache.commons.lang3.StringUtils;\nimport javax.servlet.ServletException;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\nimport javax.servlet.http.HttpSession;\nimport java.io.IOException;\nimport java.util.Objects;\n@Component\npublic class CaptchaCodeFilter extends OncePerRequestFilter {\n\n    @Resource\n    MyAuthenticationFailureHandler myAuthenticationFailureHandler;\n\n    @Override\n    protected void doFilterInternal(HttpServletRequest request,\n                                    HttpServletResponse response,\n                                    FilterChain filterChain)\n            throws ServletException, IOException {\n        // 只有在登录请求时才有验证码校验\n        if(StringUtils.equals(\"/login\",request.getRequestURI())\n                && StringUtils.equalsIgnoreCase(request.getMethod(),\"post\")){\n            try{\n                //验证谜底与用户输入是否匹配\n                this.validate(new ServletWebRequest(request));\n            }catch(AuthenticationException e){\n                myAuthenticationFailureHandler.onAuthenticationFailure(\n                        request,response,e\n                );\n                //catch异常后,之后的过滤器就不再执行了\n                return;\n            }\n\n        }\n        filterChain.doFilter(request,response);\n    }\n\n    /**\n     * 验证码 校验\n     * @param request\n     * @throws ServletRequestBindingException\n     */\n    private void validate(ServletWebRequest request) throws ServletRequestBindingException {\n\n        HttpSession session = request.getRequest().getSession();\n\n        String codeInRequest = ServletRequestUtils.getStringParameter(\n                request.getRequest(),\"captchaCode\");\n        if(StringUtils.isEmpty(codeInRequest)){\n            throw new SessionAuthenticationException(\"验证码不能为空\");\n        }\n\n        // 3. 获取session池中的验证码谜底\n        CaptchaImageVO codeInSession = (CaptchaImageVO)\n                session.getAttribute(MyContants.CAPTCHA_SESSION_KEY);\n        if(Objects.isNull(codeInSession)) {\n            throw new SessionAuthenticationException(\"验证码不存在\");\n        }\n\n        // 4. 校验服务器session池中的验证码是否过期\n        if(codeInSession.isExpired()) {\n            session.removeAttribute(MyContants.CAPTCHA_SESSION_KEY);\n            throw new SessionAuthenticationException(\"验证码已经过期\");\n        }\n\n        // 5. 请求验证码校验\n        if(!StringUtils.equals(codeInSession.getCode(), codeInRequest)) {\n            throw new SessionAuthenticationException(\"验证码不匹配\");\n        }\n\n    }\n}\n```\n\n配置中加入\n\n```java\nhttp.addFilterBefore(captchaCodeFilter, UsernamePasswordAuthenticationFilter.class)\n```\n\n\n\n\n\n### 短信验证码登录功能\n\n\n\n\n\n\n\n## 第三章、JWT\n\n### JWT使用场景及架构安全\n\n\n\n<img src=\"C:\\Users\\guosz\\OneDrive\\桌面\\image-20201209190002470.png\" alt=\"image-20201209190002470\" style=\"zoom:50%;\" />\n\n\n\nSession不使用场景\n\n- 比如：非浏览器的客户端，手机移动端等等，因为他们没有浏览器自动维护cookie的功能\n- 比如：集群应用，同一个应用部署甲、乙、丙三个主机上，实现负载均衡应用，其中一个挂掉了其他还能负债工作。要知道session是保存在服务器内存里面的，三个主机一定是不同的内存。那么你登录的时候访问甲，而获取接口数据的时候访问的是乙，就无法保证session的唯一性共享性\n\n\n\nJWT令牌的使用方式\n\n<img src=\"C:\\Users\\guosz\\OneDrive\\桌面\\image-20201209191218819.png\" alt=\"image-20201209191218819\" style=\"zoom:50%;\" />\n\n\n\n##### JWT安全加强\n\n- 避免网络劫持，因为使用HTTPd的head传递JWT，所以要使用Https传输跟安全。这样在网络层面避免了JWT的泄露。\n- secret 是存放在服务器端的，所以只要应用服务器不被攻破，理论上JWT是安全的。因此要保证服务器的安全\n\n\n\n##### 实现原理\n\n<img src=\"C:\\Users\\guosz\\OneDrive\\桌面\\image-20201209203816547.png\" alt=\"image-20201209203816547\" style=\"zoom:50%;\" />\n\n\n\n\n\n\n\n##### JWT集成\n\n1. \n\n   ```xml\n     <dependency>\n               <groupId>io.jsonwebtoken</groupId>\n               <artifactId>jjwt</artifactId>\n               <version>0.9.0</version>\n     </dependency>\n   ```\n\n   \n\n2. 写一个JwtUtils配置类\n\n   ```java\n   import io.jsonwebtoken.Claims;\n   import io.jsonwebtoken.Jwts;\n   import io.jsonwebtoken.SignatureAlgorithm;\n   import lombok.Data;\n   import org.springframework.boot.context.properties.ConfigurationProperties;\n   import org.springframework.security.core.userdetails.UserDetails;\n   import org.springframework.stereotype.Component;\n   \n   import java.util.Date;\n   import java.util.HashMap;\n   import java.util.Map;\n   @Data\n   @ConfigurationProperties(prefix = \"jwt\")\n   @Component\n   public class JWTTokenUtils {\n   \n       private String secret;\n       private Long expiration;\n       private String header;\n   \n       /**\n        * 生成token令牌\n        *\n        * @param userDetails 用户\n        * @return 令token牌\n        */\n       public String generateToken(UserDetails userDetails) {\n           Map<String, Object> claims = new HashMap<>(2);\n           claims.put(\"sub\", userDetails.getUsername());\n           claims.put(\"created\", new Date());\n   \n           return generateToken(claims);\n       }\n   \n       /**\n        * 从令牌中获取用户名\n        * @param token 令牌\n        * @return  用户名\n        */\n       public String getUsernameFromToken(String token){\n           String username;\n           try {\n               Claims claims=getClaimsFromToken(token);\n               username=claims.getSubject();\n           }catch (Exception e){\n               username=null;\n           }\n           return username;\n       }\n   \n       /**\n        * 判断令牌是否过期\n        * @param token 令牌\n        * @return  是否过期\n        */\n       public Boolean isTokenExpired(String token){\n           try {\n               Claims claims=getClaimsFromToken(token);\n               Date expiration=claims.getExpiration();\n               return expiration.before(new Date());\n           }catch (Exception e){\n               return false;\n           }\n       }\n   \n       /**\n        * 刷新令牌\n        * @param token 原令牌\n        * @return  旧令牌\n        */\n       public String refreshToken(String token){\n           String refreshedToken;\n           try {\n               Claims claims=getClaimsFromToken(token);\n               claims.put(\"created\",new Date());\n               refreshedToken=generateToken(claims);\n           }catch (Exception e){\n               refreshedToken=null;\n           }\n           return refreshedToken;\n       }\n   \n       /**\n        * 验证令牌\n        * @param token 令牌\n        * @param userDetails   用户\n        * @return     是否有效\n        */\n   \n       public Boolean validateToken(String token,UserDetails userDetails){\n           String username=getUsernameFromToken(token);\n           return (username.equals(userDetails.getUsername())) && !isTokenExpired(token);\n       }\n   \n   \n       /**\n        * 从claims生成令牌，如果看不董就看谁调用它\n        * @param claims 数据声明\n        * @return 令牌\n        */\n       private String generateToken (Map<String,Object> claims){\n           Date expirationDate=new Date(System.currentTimeMillis()+expiration);\n           return Jwts.builder().setClaims(claims)\n                   .setExpiration(expirationDate)\n                   .signWith(SignatureAlgorithm.HS512,secret)\n                   .compact();\n       }\n   \n   \n       private Claims getClaimsFromToken(String token){\n   \n           Claims claims;\n           try {\n               claims=Jwts.parser().setSigningKey(secret).parseClaimsJws(token).getBody();\n           }catch (Exception e){\n               claims=null;\n           }\n           return claims;\n       }\n   }\n   \n   ```\n\n   \n\n3. 可以配置到yml文件里面\n\n   ```yml\n   jwt:\n     secret: xjwiodcjcjwdoicijd\n     expiration: 3600000\n     header: JWTHeaderName\n   ```\n\n4. Controller\n\n   ```java\n   import com.zhaoguoshun.jwtserver.exception.AjaxResponse;\n   import com.zhaoguoshun.jwtserver.exception.CustomException;\n   import com.zhaoguoshun.jwtserver.exception.CustomExceptionType;\n   import org.apache.commons.lang3.StringUtils;\n   import org.springframework.beans.factory.annotation.Autowired;\n   import org.springframework.web.bind.annotation.*;\n   \n   import java.util.Map;\n   \n   @RestController\n   public class JwtAuthController {\n   \n       @Autowired\n       private JwtAuthService jwtAuthService;\n   \n   \n       @RequestMapping(\"/authentication\")\n       public AjaxResponse login(@RequestBody Map<String,String> map){\n           String username =map.get(\"username\");\n           String password=map.get(\"password\");\n   \n           if (StringUtils.isEmpty(username) || StringUtils.isEmpty(password)){\n               return  AjaxResponse.error(\n                       new CustomException(CustomExceptionType.USER_INPUT_ERROR ,\"用户名或者密码不能为空\")\n               );\n           }\n           try {\n               return AjaxResponse.success(jwtAuthService.login(username,password));\n           }catch (CustomException e){\n               return  AjaxResponse.error(e);\n           }\n       }\n   \n      @RequestMapping(\"/refreshtoken\")\n       public AjaxResponse refresh(@RequestHeader(\"${jwt.header}\") String token){\n           return AjaxResponse.success(jwtAuthService.refreshToken(token));\n      }\n   }\n   ```\n\n   \n\n5. 测试一下，发送了一个请求得到了令牌\n\n   <img src=\"C:\\Users\\guosz\\OneDrive\\桌面\\image-20201210163610149.png\" alt=\"image-20201210163610149\" style=\"zoom:50%;\" />\n\n6. 我们鉴权需要过滤\n\n   ```java\n   import com.zhaoguoshun.jwtserver.service.MyUserDetailService;\n   import org.apache.commons.lang3.StringUtils;\n   import org.apache.logging.log4j.core.tools.picocli.CommandLine;\n   import org.springframework.beans.factory.annotation.Autowired;\n   import org.springframework.security.authentication.UsernamePasswordAuthenticationToken;\n   import org.springframework.security.core.context.SecurityContextHolder;\n   import org.springframework.security.core.userdetails.UserDetails;\n   import org.springframework.stereotype.Component;\n   import org.springframework.web.filter.OncePerRequestFilter;\n   \n   import javax.servlet.FilterChain;\n   import javax.servlet.ServletException;\n   import javax.servlet.http.HttpServletRequest;\n   import javax.servlet.http.HttpServletResponse;\n   import java.io.IOException;\n   \n   @Component\n   public class JwtAuthenticationTokenFilter extends OncePerRequestFilter {\n   \n       @Autowired\n       private JwtTokenUtil jwtTokenUtil;\n   \n       @Autowired\n       private MyUserDetailService myUserDetailService;\n   \n   \n       @Override\n       protected void doFilterInternal(HttpServletRequest request,\n                                       HttpServletResponse response,\n                                       FilterChain filterChain)\n               throws ServletException, IOException {\n           String JwtToken = request.getHeader(jwtTokenUtil.getHeader());\n           if (!StringUtils.isEmpty(JwtToken)){\n               String username=jwtTokenUtil.getUsernameFromToken(JwtToken);\n   \n               if (username!=null &&\n                       SecurityContextHolder.getContext().getAuthentication()==null){\n                   UserDetails userDetails = myUserDetailService.loadUserByUsername(username);\n                   if (jwtTokenUtil.validateToken(JwtToken,userDetails)){\n                       //给使用该JWT令牌的用户进行授权\n                       UsernamePasswordAuthenticationToken authenticationToken\n                               =new UsernamePasswordAuthenticationToken(userDetails,null,userDetails.getAuthorities());\n                       SecurityContextHolder.getContext().setAuthentication(authenticationToken);\n                   }\n               }\n           }\n   \n           filterChain.doFilter(request,response);\n       }\n   }\n   \n   ```\n\n   \n\n7. 再每次请求的时候都都再请求头上加上生成的令牌\n\n   <img src=\"C:\\Users\\guosz\\OneDrive\\桌面\\image-20201210164016061.png\" alt=\"image-20201210164016061\" style=\"zoom:50%;\" />\n\n8. ', 320, '2020-12-22', 'A');
INSERT INTO `tb_channel` VALUES (20, 'Java基础', 19, 'http://localhost:8081/cms/upload/c6edf267-7ce3-4610-ac5d-46f7bbb79f4c.jpg', '使用Mybatis需要导入相关的Maven依赖包\r\n1.mysql依赖包\r\n2.mybatis依赖包\r\n3.junit依赖包\r\n\r\n需要把这些导入pom.xml的 dependencies中', 'Y', '', '', '', '', '', 320, '2020-12-22', 'A');
INSERT INTO `tb_channel` VALUES (21, '机器学习', 0, '', '使用Mybatis需要导入相关的Maven依赖包\r\n1.mysql依赖包\r\n2.mybatis依赖包\r\n3.junit依赖包\r\n\r\n需要把这些导入pom.xml的 dependencies中', 'N', '', '', '', '', '', 320, '2020-12-22', 'A');
INSERT INTO `tb_channel` VALUES (22, '分布式', 0, '', '', 'N', '', '', '', '', '', 320, '2020-12-22', 'B');
INSERT INTO `tb_channel` VALUES (23, '大数据', 0, '', '', 'N', '', '', '', '', '', 320, '2020-12-22', 'B');
INSERT INTO `tb_channel` VALUES (24, '通知公告', 0, '', '', 'N', '', '', '', '', '', 320, '2020-12-22', 'C');
INSERT INTO `tb_channel` VALUES (25, 'Spring', 0, '', '', 'N', '', '', '', '', '', 320, '2020-12-24', 'B');
INSERT INTO `tb_channel` VALUES (30, '框架', 0, '', 'cdscsd', 'Y', '', '', '', '', 'sddcscdcsdcsd', 320, '2020-12-26', 'A');

-- ----------------------------
-- Table structure for tb_comment
-- ----------------------------
DROP TABLE IF EXISTS `tb_comment`;
CREATE TABLE `tb_comment`  (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `author` varchar(100) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NULL DEFAULT NULL COMMENT '评论者',
  `email` varchar(100) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NULL DEFAULT NULL COMMENT '邮箱',
  `create_date` date NULL DEFAULT NULL COMMENT '创建时间',
  `content` text CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NULL COMMENT '正文',
  `status` int(1) NULL DEFAULT NULL COMMENT '0 待批准，1已通过2未通过',
  `article_id` int(11) NULL DEFAULT NULL COMMENT '文章ID',
  PRIMARY KEY (`id`) USING BTREE
) ENGINE = InnoDB CHARACTER SET = utf8mb4 COLLATE = utf8mb4_0900_ai_ci COMMENT = '评论' ROW_FORMAT = Dynamic;

-- ----------------------------
-- Records of tb_comment
-- ----------------------------
INSERT INTO `tb_comment` VALUES (1, '小顺', 'cdfcvc@qq.com', '2020-12-20', 'HELLO,顺', 0, 1);

-- ----------------------------
-- Table structure for tb_friend_link
-- ----------------------------
DROP TABLE IF EXISTS `tb_friend_link`;
CREATE TABLE `tb_friend_link`  (
  `id` int(11) NOT NULL AUTO_INCREMENT COMMENT 'ID',
  `url` varchar(100) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NULL DEFAULT NULL COMMENT '链接URL',
  `title` varchar(100) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NULL DEFAULT NULL,
  `target` varchar(50) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NULL DEFAULT NULL,
  PRIMARY KEY (`id`) USING BTREE
) ENGINE = InnoDB CHARACTER SET = utf8mb4 COLLATE = utf8mb4_0900_ai_ci COMMENT = '友情链接' ROW_FORMAT = Dynamic;

-- ----------------------------
-- Records of tb_friend_link
-- ----------------------------
INSERT INTO `tb_friend_link` VALUES (8, 'http://zhaoguoshun.cn:8083/', '顺鑫博客', '_blank');

-- ----------------------------
-- Table structure for tb_tag
-- ----------------------------
DROP TABLE IF EXISTS `tb_tag`;
CREATE TABLE `tb_tag`  (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `tag_name` varchar(50) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NULL DEFAULT NULL,
  PRIMARY KEY (`id`) USING BTREE
) ENGINE = InnoDB AUTO_INCREMENT = 6 CHARACTER SET = utf8mb4 COLLATE = utf8mb4_0900_ai_ci ROW_FORMAT = Dynamic;

-- ----------------------------
-- Records of tb_tag
-- ----------------------------
INSERT INTO `tb_tag` VALUES (4, '赵国顺');
INSERT INTO `tb_tag` VALUES (5, 'Java');
INSERT INTO `tb_tag` VALUES (6, 'Vue');

-- ----------------------------
-- Table structure for tb_user
-- ----------------------------
DROP TABLE IF EXISTS `tb_user`;
CREATE TABLE `tb_user`  (
  `id` int(11) NOT NULL AUTO_INCREMENT COMMENT 'ID',
  `user_name` varchar(100) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NULL DEFAULT NULL COMMENT '用户名',
  `password` varchar(100) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NULL DEFAULT NULL COMMENT '密码',
  `nick_name` varchar(100) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NULL DEFAULT NULL COMMENT '名称',
  `email` varchar(100) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NULL DEFAULT NULL COMMENT '邮箱',
  `avatar` varchar(100) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NULL DEFAULT NULL COMMENT '头像',
  `create_date` date NULL DEFAULT NULL COMMENT '创建时间',
  `status` char(1) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NULL DEFAULT NULL COMMENT 't代表正常，f代表禁用，d代表删除',
  PRIMARY KEY (`id`) USING BTREE
) ENGINE = InnoDB AUTO_INCREMENT = 353 CHARACTER SET = utf8mb4 COLLATE = utf8mb4_0900_ai_ci ROW_FORMAT = Dynamic;

-- ----------------------------
-- Records of tb_user
-- ----------------------------
INSERT INTO `tb_user` VALUES (332, 'cdv xf', 'cdscsdd', 'dscd', 'cdcds', NULL, '2020-12-16', 'T');
INSERT INTO `tb_user` VALUES (333, 'vfdv', 'vfdvf', 'vfdfv', 'vfdv', NULL, '2020-12-16', 'T');
INSERT INTO `tb_user` VALUES (334, 'csd', 'btyhb', 'btny', 'bty', NULL, '2020-12-16', 'T');
INSERT INTO `tb_user` VALUES (335, 'zhaofw', 'cdsnj', 'cds', 'csdml', NULL, '2020-12-16', 'T');
INSERT INTO `tb_user` VALUES (336, 'zhaofw', 'cdsnj', 'cds', 'csdml', NULL, '2020-12-16', 'T');
INSERT INTO `tb_user` VALUES (337, 'zhaofw', 'cdsnj', 'cds', 'csdml', NULL, '2020-12-16', 'T');
INSERT INTO `tb_user` VALUES (338, 'zhaofw', 'cdsnj', 'cds', 'csdml', NULL, '2020-12-16', 'T');
INSERT INTO `tb_user` VALUES (339, 'lkj', 'j', 'ghj', 'hj', NULL, '2020-12-16', 'T');

SET FOREIGN_KEY_CHECKS = 1;
